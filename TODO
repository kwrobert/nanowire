Code
====

1) Fix simulation subproccesing in sim_wrapper so we get output/feedback from S4 library when
   verbosity > 1
2) Fix automatic post processing so we get feedback to stdout as well as logs
3) Add error checking of plane values in setup.ini to make sure they do not exceed number of samples
4) Parallelize postprocessing
5) Add capability to look up minimum number of basis terms to sim_wrapper 
    a) Will need to create a database. Store number of basis terms for each combination of
       frequency and some reasonable number of geometric parameters. 
5) Fix comsol_compare.py so it grabs quantities by column header 
6) Begin working on interface code to Sentaurus/Electrical Sims. This involves:
   a) Averaging over frequency to get average generation rate
   b) Initiating Sentaurus to get the mesh it builds
   b) Interpolating regular S4 grid onto Sentaurus mesh
   c) Building out Sentaurus config files
7) Add counter to simulation sweeps so we know how many are left to run 
8) Fix limits on 2D color plots to remove whitespace
9) Fix API of the optics code, mainly the postprocess.py file. Right now it has all this convoluted
   fucked up logic and setting the data for a single sim as an attribute makes parallization
   impossible. We should fix things as follows: 
    a) Each processor object should have a function that accepts a single sim config object as an
       argument, and does its job on that simulation. We can then easily parallelize this. Call this
       function "process", raise NotImplementedError in base class but override in child classes. 
    b) Will need to remove the dependency on the self.data attribute. Every function that performs
       some operation on data needs to explicitly receive that data as an argument. Note we can
       still keep the header attributes as it will force our data to maintain the proper column
       structure. This point is mainly relevant to Cruncher and Global_Cruncher 
    c) Can still have some large, monolithic function that, given some master config file for a
       sweep, will do its job on all sims in the sweep. This will just be a simple loop/wrapper 
       around the basic "process" function. Boolean kwarg that determines whether or not to run in
       parallel. 
10) Maybe someday create a Java CLI program that wraps COMSOL nanowire model. 
11) Need to add function to processors that extract all params and their values from the master
    config file and stores then in a dictionary as an attribute. Allows us to plot different combos
    of parameters with ease. Ex: sweep thru period, frequency, and basis terms. Plot run time of 220
    basis term sim for all frequencies at each period and store at the period node. 

Reading
=======

1) Read Rays paper and identify any gaps in their optimization that we could fill
    a) Notes in Zotero
2) F̶i̶n̶d̶/̶a̶s̶k̶ ̶f̶o̶r̶ ̶g̶e̶n̶e̶r̶a̶t̶i̶o̶n̶ ̶r̶a̶t̶e̶ ̶d̶o̶c̶u̶m̶e̶n̶t̶ ̶A̶n̶n̶a̶ ̶m̶a̶d̶e̶ ̶a̶n̶d̶ ̶r̶e̶a̶d̶ ̶i̶t̶
    a) Handwritten notes up on Dropbox. Kind of a mess. Will need to decrpypt it in the future
3) Genetic algorithm book that I downloaded. Should be somewhere in papers/  
4) Software design patterns book. Stored in zotero. 

Simulation and Data Analysis
============================

1) Run a full convergence analysis for different system sizes
    a) p̶e̶r̶i̶o̶d̶ ̶2̶0̶0̶ ̶n̶m̶,̶ ̶r̶a̶d̶i̶u̶s̶ ̶7̶5̶
    b) p̶e̶r̶i̶o̶d̶ ̶3̶0̶0̶ ̶n̶m̶,̶ ̶r̶a̶d̶i̶u̶s̶ ̶6̶0̶
    c) N̶e̶e̶d̶ ̶t̶o̶ ̶f̶i̶n̶d̶ ̶s̶i̶m̶s̶ ̶t̶h̶a̶t̶ ̶f̶a̶i̶l̶e̶d̶,̶ ̶r̶e̶-̶r̶u̶n̶,̶ ̶t̶h̶e̶n̶ ̶c̶o̶m̶p̶l̶e̶t̶e̶ ̶p̶o̶s̶t̶p̶r̶o̶c̶e̶s̶s̶i̶n̶g̶ ̶
        i) All failed simulations are running or complete 
2) Run simulation with fixed total nanowire radius, but vary ratio between shell thickness
   and core radius 
3) P̶l̶o̶t̶ ̶t̶h̶e̶ ̶t̶i̶m̶e̶ ̶s̶c̶a̶l̶i̶n̶g̶ ̶f̶o̶r̶ ̶e̶a̶c̶h̶ ̶v̶e̶c̶t̶o̶r̶ ̶f̶i̶e̶l̶d̶ ̶c̶o̶n̶f̶i̶g̶ ̶o̶n̶ ̶t̶h̶e̶ ̶s̶a̶m̶e̶ ̶s̶e̶t̶ ̶o̶f̶ ̶a̶x̶e̶s̶ ̶f̶o̶r̶ ̶a̶ ̶f̶i̶x̶e̶d̶ ̶f̶r̶e̶q̶u̶e̶n̶c̶y̶
 ̶ ̶ ̶f̶o̶r̶ ̶e̶a̶c̶h̶ ̶s̶y̶s̶t̶e̶m̶ ̶s̶i̶z̶e̶.̶ ̶T̶h̶i̶s̶ ̶w̶i̶l̶l̶ ̶m̶a̶k̶e̶ ̶i̶t̶ ̶a̶p̶p̶a̶r̶e̶n̶t̶ ̶w̶h̶i̶c̶h̶ ̶c̶o̶n̶f̶i̶g̶ ̶i̶s̶ ̶t̶h̶e̶ ̶f̶a̶s̶t̶e̶s̶t̶,̶ ̶a̶n̶d̶ ̶w̶i̶l̶l̶ ̶t̶e̶l̶l̶ ̶u̶s̶
 ̶ ̶ ̶w̶h̶e̶t̶h̶e̶r̶ ̶o̶r̶ ̶n̶o̶t̶ ̶v̶e̶c̶t̶o̶r̶ ̶f̶i̶e̶l̶d̶ ̶c̶r̶e̶a̶t̶i̶o̶n̶ ̶d̶e̶p̶e̶n̶d̶s̶ ̶o̶n̶ ̶s̶y̶s̶t̶e̶m̶ ̶s̶i̶z̶e̶.̶ ̶
    a) Appears that there is little to no difference in run time, meaning the time savings by 
       reducing basis terms is worthwhile. Also, minimum required # of basis terms is heavily
       dependent on system size. 
   
Other
====

1) Create documentation for the code and all calculations 
