
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Tutorial &#8212; Nanowire .1 documentation</title>
    
    <link rel="stylesheet" href="_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Code" href="Code.html" />
    <link rel="prev" title="Introduction" href="Introduction.html" />
   
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="tutorial">
<h1>Tutorial<a class="headerlink" href="#tutorial" title="Permalink to this headline">¶</a></h1>
<div class="section" id="yaml-input-file">
<h2>YAML Input File<a class="headerlink" href="#yaml-input-file" title="Permalink to this headline">¶</a></h2>
<p>For starters, here is a complete input YAML file, you could copy and paste this
into some text file on your machine and be ready to roll. The comments in here
well describe what all the various options do.</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">General</span><span class="p">:</span>
    <span class="c1"># Base directory under which to run your simulation(s). The simulations are</span>
    <span class="c1"># going to spit out a bunch of data in subdirectories of this directory.</span>
    <span class="n">base_dir</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/tests/ang_avg_tests&#39;</span>
    <span class="c1"># Same as above but remains untouched during buildout of directory tree</span>
    <span class="c1"># beneath basedir. This is only relevant for an old branch of the code</span>
    <span class="c1"># that organizes parameter sweeps in a nested directory tree. I&#39;ve sinced</span>
    <span class="c1"># moved from a tree structure to a single layer of subdirectories because</span>
    <span class="c1"># the static nature of directory trees was becoming cumbersome.</span>
    <span class="n">treebase</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/tests/ang_avg_tests&#39;</span>
    <span class="c1"># Output file base name for fields. The E field files will be saved in</span>
    <span class="c1"># $base_dir/somedir/field_data.E.$ext and the hfields as field_data.E.$ext </span>
    <span class="n">base_name</span><span class="p">:</span> <span class="s1">&#39;field_data&#39;</span>
    <span class="c1"># Whether or not to use multiple processes/threads (haven&#39;t decided yet)</span>
    <span class="c1"># when postprocessing data to speed up results. This currently doesn&#39;t</span>
    <span class="c1"># work yet because of the way my postprocessing code is structured (can&#39;t</span>
    <span class="c1"># pickle logger objects). However, I have an idea for how I can fix this</span>
    <span class="c1"># that will be implemented soonish. </span>
    <span class="n">post_parallel</span><span class="p">:</span> <span class="kc">False</span>
    <span class="c1"># Tells the sim_wrapper script to either run simulations serially (1 at a</span>
    <span class="c1"># time) or  use multiprocessing to run multiple simulations in parallel.</span>
    <span class="c1"># Each simulation runs a unique combination of parameters you happen to be</span>
    <span class="c1"># sweeping through. </span>
    <span class="c1"># Options: [&#39;serial&#39;, &#39;parallel&#39;]</span>
    <span class="n">execution</span><span class="p">:</span> <span class="s1">&#39;parallel&#39;</span>
    <span class="c1"># The number of cores you would like to use when running in parallel. </span>
    <span class="n">num_cores</span> <span class="p">:</span> <span class="mi">6</span>
    <span class="c1"># Adaptive convergence. This will run multiple sims (up to max_iter of</span>
    <span class="c1"># them) for each set of params, increasing the number of basis terms by</span>
    <span class="c1"># basis_step until converged within max_diff</span>
    <span class="n">adaptive_convergence</span><span class="p">:</span> <span class="kc">False</span>
    <span class="n">max_iter</span><span class="p">:</span> <span class="mi">5</span> 
    <span class="n">max_diff</span><span class="p">:</span> <span class="o">.</span><span class="mi">02</span>
    <span class="n">basis_step</span><span class="p">:</span> <span class="mi">20</span>
    <span class="c1"># This bit configures the optimizer. This only matters if you parameters</span>
    <span class="c1"># are of the &#39;optimized&#39; type.</span>
    <span class="c1"># opt_max_iter: Maximum number of optimization loops to run</span>
    <span class="c1"># opt_tol: The tolerance for the parameters you are optimizing</span>
    <span class="c1"># func_opt_tol: The tolerance for the objective function you are optimizer</span>
    <span class="c1"># over</span>
    <span class="c1"># opt_keep_intermediates: Keep all the intermediate results generation at</span>
    <span class="c1"># each iteration</span>
    <span class="c1"># DANGER!!: Setting opt_keep_intermediates to True has to potentially to</span>
    <span class="c1"># rapidly consume all of your disk space. Be cautious.</span>
    <span class="n">opt_max_iter</span><span class="p">:</span> <span class="mi">60</span>
    <span class="n">opt_tol</span><span class="p">:</span> <span class="mf">1e-4</span>
    <span class="n">opt_keep_intermediates</span><span class="p">:</span> <span class="kc">False</span>
    <span class="c1"># Would you like to save the plots for each sim?</span>
    <span class="n">save_plots</span><span class="p">:</span> <span class="kc">True</span>
    <span class="c1"># Would you like to show the plots during postprocessing in real time?</span>
    <span class="n">show_plots</span><span class="p">:</span> <span class="kc">False</span>
    <span class="c1"># File type to save any generated arrays as. Choose from (text, npz). </span>
    <span class="c1"># Text saves in tab delimited text files, npz saves in compressed numpy</span>
    <span class="c1"># binary format</span>
    <span class="n">save_as</span><span class="p">:</span> <span class="s1">&#39;npz&#39;</span>
    <span class="c1"># Save timing data for each simulation?</span>
    <span class="n">save_time</span><span class="p">:</span> <span class="kc">True</span>
    <span class="c1"># Output the in plane geometry for each layer. Helpful for debugging</span>
    <span class="n">output_pattern</span><span class="p">:</span> <span class="kc">True</span>
    <span class="c1"># If true, don&#39;t compute the H fields to save disk space. I think even if</span>
    <span class="c1"># you set this to False at the moment the code still wouldn&#39;t compute the H</span>
    <span class="c1"># field lol</span>
    <span class="n">ignore_h</span><span class="p">:</span> <span class="kc">True</span>

<span class="n">Solver</span><span class="p">:</span>
<span class="c1"># These options configure the various FMM formulations used within the simulation. See</span>
<span class="c1"># the S4 docs and paper for details </span>

<span class="c1">## These are the defaults</span>
<span class="c1">#Verbosity = 0</span>
<span class="c1">#LatticeTruncation = Circular</span>
<span class="c1">#DiscretizedEpsilon = False</span>
<span class="c1">#DiscretizationResolution = 8</span>
<span class="c1">#PolarizationDecomposition = False</span>
<span class="c1">#PolarizationBasis = Default</span>
<span class="c1">#LanczosSmoothing = False</span>
<span class="c1">#SubpixelSmoothing = False</span>
<span class="c1">#ConserveMemory = False</span>
    <span class="n">Verbosity</span><span class="p">:</span> <span class="mi">0</span>
    <span class="n">LatticeTruncation</span><span class="p">:</span> <span class="s1">&#39;Circular&#39;</span>
    <span class="p">[</span><span class="n">DiscretizedEpsilon</span><span class="p">](</span><span class="n">DiscretizedEpsilon</span><span class="p">):</span> <span class="kc">False</span>
    <span class="n">DiscretizationResolution</span><span class="p">:</span> <span class="mi">8</span>
    <span class="n">PolarizationDecomposition</span><span class="p">:</span> <span class="kc">True</span>
    <span class="n">PolarizationBasis</span><span class="p">:</span> <span class="s1">&#39;Default&#39;</span>
    <span class="n">LanczosSmoothing</span><span class="p">:</span> <span class="kc">False</span>
    <span class="n">SubpixelSmoothing</span><span class="p">:</span> <span class="kc">False</span>
    <span class="n">ConserveMemory</span><span class="p">:</span> <span class="kc">False</span>

<span class="n">Simulation</span><span class="p">:</span>
    <span class="c1"># This section handles global simulation parameters that are not specific to any given</span>
    <span class="c1"># layer. For example, the lattice vectors or the angle of incident light</span>

    <span class="c1"># The polarization of incident light</span>
    <span class="c1"># Right Hand Circularly Polarized : rhcp</span>
    <span class="c1"># Left Hand Circularly Polarized : lhcp</span>
    <span class="c1"># Linearly Polarized Along X : lpx</span>
    <span class="c1"># Linearly Polarized Along Y : lpy</span>
    <span class="n">polarization</span><span class="p">:</span> <span class="s1">&#39;rhcp&#39;</span>
    <span class="c1"># Number of field samples to take in the x, y, and z directions</span>
    <span class="n">x_samples</span><span class="p">:</span> <span class="mi">10</span>
    <span class="n">y_samples</span><span class="p">:</span> <span class="mi">10</span>
    <span class="n">z_samples</span><span class="p">:</span> <span class="mi">20</span>
    <span class="c1"># If computing an angular average of any fields, the number of samples to</span>
    <span class="c1"># use in polar coordinates</span>
    <span class="n">r_samples</span> <span class="p">:</span> <span class="mi">150</span>
    <span class="n">theta_samples</span> <span class="p">:</span> <span class="mi">360</span>
    <span class="c1"># Maximum depth from top of device to collect fields. If you have a really</span>
    <span class="c1"># thick, absorbing substrate there probably isn&#39;t anything interesting</span>
    <span class="c1"># going on beyond 3 or 4 microns</span>
    <span class="c1"># This is an example of two things: Parameter substitution and parameter</span>
    <span class="c1"># evaluation. I will discuss what those mean elsewhere</span>
    <span class="n">max_depth</span><span class="p">:</span> <span class="s1">&#39;`%(Layers.Air.params.thickness.value)s+%(Layers.ITO.params.thickness.value)s+%(Layers.NW_AlShell.params.thickness.value)s+3`&#39;</span>
    <span class="c1"># Base length unit defined relative to a meter (so nm would be 1E-9,</span>
    <span class="c1"># micrometers would be 1E-6, etc). This is necessary because S4 requires</span>
    <span class="c1"># you to define all geometric parameters relative to some base reference</span>
    <span class="c1"># unit. Any parameters you enter should be expressed as some multiple of</span>
    <span class="c1"># that base unit. So here, the reference unit is a micrometer, and all</span>
    <span class="c1"># lengths with be specified as some multiple of a micrometer.</span>
    <span class="n">base_unit</span><span class="p">:</span> <span class="mf">1.0E-6</span>
    <span class="c1"># Path to input spectrum file. Modify the paths as necessary to point to</span>
    <span class="c1"># the location of the nanowire repo on your machine. These files must</span>
    <span class="c1"># conform to a very specific format, see the files in the repo for an</span>
    <span class="c1"># example. </span>
    <span class="n">input_power</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/am15g_freq.txt&#39;</span>
    <span class="n">input_power_wv</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/ASTMG173.csv&#39;</span> <span class="c1"># not actually sure why this one is here. Must fix</span>
    <span class="c1"># Global simulation parameters that are &quot;sweepable&quot;</span>
    <span class="n">params</span><span class="p">:</span>
        <span class="c1"># The angle of the incident light</span>
        <span class="n">polar_angle</span><span class="p">:</span>
            <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">0</span>
        <span class="n">azimuthal_angle</span><span class="p">:</span> 
            <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">0</span>
        <span class="c1"># Periodicity of the square array. With our current units, this would</span>
        <span class="c1"># be 325.5 nm period </span>
        <span class="c1"># NOTE: Currently this only supports a square</span>
        <span class="c1"># lattice. Support for non-square unit cells may be added in the future</span>
        <span class="n">array_period</span><span class="p">:</span>
            <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
            <span class="n">value</span><span class="p">:</span> <span class="o">.</span><span class="mi">3255</span> 
        <span class="c1"># Incident frequencies to simulate</span>
        <span class="n">frequency</span><span class="p">:</span>
            <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;variable&#39;</span>
            <span class="n">start</span><span class="p">:</span> <span class="mf">333102731111111.1</span>
            <span class="n">end</span><span class="p">:</span> <span class="mf">856549880000000.0</span>
            <span class="n">step</span><span class="p">:</span> <span class="mi">20</span>
            <span class="n">itertype</span><span class="p">:</span> <span class="s1">&#39;numsteps&#39;</span>
        <span class="c1"># Number of basis terms to use in the RCWA solver. Increasing this</span>
        <span class="c1"># improves accuracy but increases simulation time as numbasis^2</span>
        <span class="n">numbasis</span><span class="p">:</span>
            <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
            <span class="n">value</span><span class="p">:</span> <span class="mi">20</span>

<span class="n">Materials</span><span class="p">:</span>
    <span class="c1"># Here is where you define all your materials. The key is the name you wish</span>
    <span class="c1"># to assign the material, and the value is an absolute path to a text file</span>
    <span class="c1"># containing the n and k data for the material. These files must be in a</span>
    <span class="c1"># specific format. See the examples in the repo. </span>
    <span class="c1"># NOTE: A default material called &quot;vacuum&quot; will be created by default. It</span>
    <span class="c1"># has n=1 and k=0 for all frequencies</span>
    <span class="n">ITO</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/008_ITO_nk_Hz.txt&#39;</span>
    <span class="n">Cyclotene</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/007_Cyclotrene_nk_Hz.txt&#39;</span>
    <span class="n">GaAs</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/006_GaAs_nk_Walker_modified_Hz.txt&#39;</span>
    <span class="n">AlInP</span><span class="p">:</span> <span class="s1">&#39;/home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/009_AlInP_nk_Hz.txt&#39;</span>

<span class="n">Layers</span><span class="p">:</span>
    <span class="c1"># Here is where you define the geometry of your device. </span>
    <span class="c1">#</span>
    <span class="c1"># The top level key here automatically creates a layer whose name is the</span>
    <span class="c1"># key</span>
    <span class="n">Air</span><span class="p">:</span>
        <span class="c1"># This specifies where in the stack of layers this layer will reside.  Layers</span>
        <span class="c1"># are sorted by increasing &quot;order&quot; parameter. Light will be incident on</span>
        <span class="c1"># the layer with the lowest value for &quot;order&quot;. </span>
        <span class="n">order</span><span class="p">:</span> <span class="mi">1</span>
        <span class="c1"># The background material for the layer, upon which any extra</span>
        <span class="c1"># geometry will be superimposed</span>
        <span class="n">base_material</span><span class="p">:</span> <span class="s1">&#39;vacuum&#39;</span>
        <span class="c1"># All the &quot;sweepable&quot; geometric parameters are contained below this key</span>
        <span class="n">params</span><span class="p">:</span>
            <span class="c1"># Every layer must have a thickness! This thickness can be zero if</span>
            <span class="c1"># you like</span>
            <span class="n">thickness</span><span class="p">:</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="o">.</span><span class="mi">5</span>
    <span class="n">ITO</span><span class="p">:</span>
        <span class="n">order</span><span class="p">:</span> <span class="mi">2</span>
        <span class="n">base_material</span><span class="p">:</span> <span class="s1">&#39;ITO&#39;</span> 
        <span class="n">params</span><span class="p">:</span>
            <span class="n">thickness</span><span class="p">:</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="o">.</span><span class="mi">3</span>
    <span class="n">NW_AlShell</span><span class="p">:</span> 
        <span class="n">order</span><span class="p">:</span> <span class="mi">3</span> 
        <span class="n">base_material</span><span class="p">:</span> <span class="s1">&#39;Cyclotene&#39;</span>
        <span class="n">params</span><span class="p">:</span>
            <span class="n">thickness</span><span class="p">:</span> 
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="mf">3.0</span>
            <span class="n">shell_radius</span><span class="p">:</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="s1">&#39;`%(Layers.NW_AlShell.params.core_radius.value)s+.03`&#39;</span>
            <span class="n">core_radius</span><span class="p">:</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="o">.</span><span class="mi">103</span>
        <span class="c1"># If you want to create a layer that has a nonuniform internal</span>
        <span class="c1"># geometry, add this key </span>
        <span class="n">geometry</span><span class="p">:</span>
            <span class="c1"># You can specify multiple shapes. Same semantics for the order</span>
            <span class="c1"># parameter. The material containined within the last shape created</span>
            <span class="c1"># overwrites the material of any shape with which it overlaps. So</span>
            <span class="c1"># notice, to make a AlInP shell with a GaAs core I set the</span>
            <span class="c1"># core[&#39;order&#39;] &gt; shell[&#39;order&#39;]</span>
            <span class="n">shell</span><span class="p">:</span>
                <span class="n">order</span><span class="p">:</span> <span class="mi">1</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;circle&#39;</span>
                <span class="n">radius</span><span class="p">:</span> <span class="s1">&#39;%(Layers.NW_AlShell.params.shell_radius.value)s&#39;</span>
                <span class="n">center</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;`%(Simulation.params.array_period.value)s/2`&#39;</span>
                    <span class="n">y</span><span class="p">:</span> <span class="s1">&#39;`%(Simulation.params.array_period.value)s/2`&#39;</span>
                <span class="n">material</span><span class="p">:</span> <span class="s1">&#39;AlInP&#39;</span>
            <span class="n">core</span><span class="p">:</span>
                <span class="n">order</span><span class="p">:</span> <span class="mi">2</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;circle&#39;</span>
                <span class="n">radius</span><span class="p">:</span> <span class="s1">&#39;%(Layers.NW_AlShell.params.core_radius.value)s&#39;</span>
                <span class="n">center</span><span class="p">:</span>
                    <span class="n">x</span><span class="p">:</span> <span class="s1">&#39;`%(Simulation.params.array_period.value)s/2`&#39;</span>
                    <span class="n">y</span><span class="p">:</span> <span class="s1">&#39;`%(Simulation.params.array_period.value)s/2`&#39;</span>
                <span class="n">material</span><span class="p">:</span> <span class="s1">&#39;GaAs&#39;</span> 
    <span class="n">Substrate</span><span class="p">:</span>
        <span class="n">order</span><span class="p">:</span> <span class="mi">4</span>
        <span class="n">base_material</span><span class="p">:</span> <span class="s1">&#39;GaAs&#39;</span>
        <span class="n">params</span><span class="p">:</span>
            <span class="n">thickness</span><span class="p">:</span>
                <span class="nb">type</span><span class="p">:</span> <span class="s1">&#39;fixed&#39;</span>
                <span class="n">value</span><span class="p">:</span> <span class="mi">100</span>

<span class="n">Postprocessing</span><span class="p">:</span>
    <span class="c1"># This configures the behavior of the postprocessor</span>
    <span class="n">Cruncher</span><span class="p">:</span>
        <span class="c1"># The quantities specific to each simulation that you would like to calculate. Specify</span>
        <span class="c1"># compute: False </span>
        <span class="c1"># to disable the calculation, and True to enable it. Arguments can be passed to each</span>
        <span class="c1"># function below as a list. If you would like to run the function multiple times with multiple</span>
        <span class="c1"># sets of arguments, specify a list of lists like so:</span>
        <span class="c1"># single run: [&#39;arg1&#39;,3,&#39;arg2&#39;]</span>
        <span class="c1"># multiple runs: [[&#39;arg1,3,&#39;arg2&#39;],[&#39;arg3&#39;,4,&#39;arg4&#39;]]</span>
        <span class="c1"># If you want to know what arguments are available, check the source</span>
        <span class="c1"># code</span>
        <span class="n">normE</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">normEsquared</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">normH</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">normHsquared</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">genRate</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">angularAvg</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;genRate&#39;</span><span class="p">]</span>
        <span class="n">transmissionData</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
    
    <span class="n">Global_Cruncher</span><span class="p">:</span>
        <span class="c1"># Compute global quantities that require simulations to be grouped</span>
        <span class="c1"># together in some way. For example, to compute J_ph you need to group</span>
        <span class="c1"># sims with identical geometry but different frequencies together and</span>
        <span class="c1"># use the Global_Cruncher to compute global quantities on each of those</span>
        <span class="c1"># groups</span>
        <span class="n">local_error</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
        <span class="n">global_error</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
        <span class="n">adjacent_error</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="kc">False</span><span class="p">]</span>
        <span class="n">scalar_reduce</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;genRate&#39;</span><span class="p">],[</span><span class="s1">&#39;normE&#39;</span><span class="p">]]</span>
        <span class="n">Jsc</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
        <span class="n">fractional_absorbtion</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span>
    
    <span class="n">Plotter</span><span class="p">:</span>
        <span class="c1"># What plots to generate. Check the source</span>
        <span class="n">full_3d</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;normE&#39;</span><span class="p">]</span>
        <span class="n">planes_3d</span><span class="p">:</span> 
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
        <span class="n">plane_2d</span><span class="p">:</span>
            <span class="c1"># 1) Value to plot</span>
            <span class="c1"># 2) x,y, or z plane?</span>
            <span class="c1"># 3) Which plane value?</span>
            <span class="c1"># 4) Draw nanowire components? (default: False)</span>
            <span class="c1"># 5) Fix colorbar limits? (default: False)</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">True</span><span class="p">],[</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">True</span><span class="p">],[</span><span class="s1">&#39;genRate&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="kc">True</span><span class="p">]]</span>
        <span class="n">fixed_line</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span><span class="s1">&#39;z&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span><span class="mi">5</span><span class="p">]</span>
    
    <span class="n">Global_Plotter</span><span class="p">:</span>
        <span class="c1"># Plot quantities for some group of simulations. Example would be an</span>
        <span class="c1"># absorption spectra of the device</span>
        <span class="n">convergence</span><span class="p">:</span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">False</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="s1">&#39;global&#39;</span><span class="p">,</span><span class="s1">&#39;log&#39;</span><span class="p">],[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="s1">&#39;local&#39;</span><span class="p">,</span><span class="s1">&#39;log&#39;</span><span class="p">],[</span><span class="s1">&#39;E&#39;</span><span class="p">,</span><span class="s1">&#39;adjacent&#39;</span><span class="p">,</span><span class="s1">&#39;log&#39;</span><span class="p">]]</span>
        <span class="n">scalar_reduce</span><span class="p">:</span> 
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[[</span><span class="s1">&#39;genRate&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">],[</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span><span class="s1">&#39;x&#39;</span><span class="p">,</span><span class="mi">5</span><span class="p">]]</span>
        <span class="n">transmission_data</span><span class="p">:</span>
            <span class="c1"># Absorbtion, Reflectance, Transmission (pass false to disable one) </span>
            <span class="n">compute</span><span class="p">:</span> <span class="kc">True</span>
            <span class="n">args</span><span class="p">:</span> <span class="p">[</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">,</span><span class="kc">True</span><span class="p">]</span>
</pre></div>
</div>
<div class="section" id="types-of-parameters">
<h3>Types of Parameters<a class="headerlink" href="#types-of-parameters" title="Permalink to this headline">¶</a></h3>
<p>There are 3 “types” of parameters to choose from:</p>
<ul class="simple">
<li>“Fixed” parameters</li>
<li>“Variable” parameters</li>
<li>“Optimized” parameters</li>
</ul>
</div>
<div class="section" id="fixed-parameters">
<h3>Fixed Parameters<a class="headerlink" href="#fixed-parameters" title="Permalink to this headline">¶</a></h3>
<p>Fixed parameters are just that, some configurable system parameter that has a
single fixed value. Specify them with</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">param_name</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">type</span><span class="p p-Indicator">:</span> <span class="s">&#39;fixed&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">value</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$your_value</span>
</pre></div>
</div>
</div>
<div class="section" id="variable-parameters">
<h3>Variable Parameters<a class="headerlink" href="#variable-parameters" title="Permalink to this headline">¶</a></h3>
<p>Variable parameters are parameters you would like to sweep through (i.e
frequency, or maybe incident angle). There are two ways to specify this:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">frequency</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">type</span><span class="p p-Indicator">:</span> <span class="s">&#39;variable&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">start</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">START</span>
    <span class="l l-Scalar l-Scalar-Plain">end</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">END</span>
    <span class="l l-Scalar l-Scalar-Plain">step</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
    <span class="l l-Scalar l-Scalar-Plain">itertype</span><span class="p p-Indicator">:</span> <span class="s">&#39;numsteps&#39;</span>
</pre></div>
</div>
<p>This says start at START and sweep up to END (inclusive of END) in 20 equally
equally spaced steps. The <cite>itertype: ‘numsteps’</cite> param tells the <cite>sim_wrapper.py</cite> script to
interpret the ‘step’ parameter as the number of steps to take. This is the
equivalent of numpy/matlab’s  <cite>linspace</cite></p>
<p>The other way to specify a variable parameter is:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">frequency</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">type</span><span class="p p-Indicator">:</span> <span class="s">&#39;variable&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">start</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">START</span>
    <span class="l l-Scalar l-Scalar-Plain">end</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">END</span>
    <span class="l l-Scalar l-Scalar-Plain">step</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">20</span>
    <span class="l l-Scalar l-Scalar-Plain">itertype</span><span class="p p-Indicator">:</span> <span class="s">&#39;stepsize&#39;</span>
</pre></div>
</div>
<p>This says sweep from START to END (inclusive) in steps of size 20.</p>
<p>You can specify multiple variable parameters. The <cite>sim_wrapper</cite> script will
automatically generate every possible unique parameter combination and run a
simulation for each one it generates.</p>
</div>
<div class="section" id="optimized-parameters">
<h3>Optimized Parameters<a class="headerlink" href="#optimized-parameters" title="Permalink to this headline">¶</a></h3>
<p>Optimized parameters are parameters you wish to optimize. The code uses the
Nelder Mead simplex optimizer from scipy for optimizations. Right now the setup
of the optimizer is a bit immature. It basically assumes you want to optimize
the photocurrent density of the device (i.e spectrum-wide absorbtion) and also
assumes that your only variable parameter is frequency. I hope to enhance this
at some point to make the objective function configurable. My current use case
it to optimize the geometry to maximize total absorption. Specify optimized
parameters with:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">param_name</span><span class="p p-Indicator">:</span>
    <span class="l l-Scalar l-Scalar-Plain">type</span><span class="p p-Indicator">:</span> <span class="s">&#39;fixed&#39;</span>
    <span class="l l-Scalar l-Scalar-Plain">value</span><span class="p p-Indicator">:</span> <span class="l l-Scalar l-Scalar-Plain">$your_value</span>
</pre></div>
</div>
<p>You can specify multiple optimized parameters. The optimizer will attempt to
optimize all of them to maximize absorption. The optimizer is NOT a global
optimizer, so be wary of falling into local minima. Also, know that as you
increase the number of parameters you optimize over the optimizer will take
longer to converge.</p>
</div>
<div class="section" id="parameter-substition">
<h3>Parameter Substition<a class="headerlink" href="#parameter-substition" title="Permalink to this headline">¶</a></h3>
<p>Within the YAML file, it is possible to refer to other parameters in the config
by inserting a specifically formatted string. This string will be replaced with
the value of the parameter to which it refers. Best illustrated with an
example:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">max_depth</span><span class="p p-Indicator">:</span> <span class="s">&#39;%(Layers.Air.params.thickness.value)s&#39;</span>
</pre></div>
</div>
<p>The thing inside the <cite>()</cite> is a dot-separated path to some location in the
config file. In the case, the value of the thickness of the air layer. The
<cite>%()s</cite> is what tells the <cite>Config</cite> object to run a substitution. Always enclose
you substitions in quotes or things will break.</p>
</div>
<div class="section" id="parameter-evaluation">
<h3>Parameter Evaluation<a class="headerlink" href="#parameter-evaluation" title="Permalink to this headline">¶</a></h3>
<p>Its possible to evaluate arbitrary python expressions by enclosing any
parameter in back ticks. There is not validation or sanitation of this
expression, so it is horribly insecure but no external, malicious entities will
be running this code or injecting anything so its not really a problem (yet).
Anyway, illustrated with an example</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">max_depth</span><span class="p p-Indicator">:</span> <span class="s">&#39;`1+2+3`&#39;</span>
</pre></div>
</div>
<p>This is silly and just says “add these numbers and set max_depth to the
result”. We could have just entered 6. However, this gets really handy when
combined with parameter substitution. Example:</p>
<div class="highlight-yaml"><div class="highlight"><pre><span></span><span class="l l-Scalar l-Scalar-Plain">max_depth</span><span class="p p-Indicator">:</span> <span class="s">&#39;`(%(Layers.Air.params.thickness.value)s+%(Layers.ITO.params.thickness.value)s+%(Layers.NW_AlShell.params.thickness.value)s+3)*2`&#39;</span>
</pre></div>
</div>
<p>This says:</p>
<ol class="arabic simple">
<li>Go get the values of all these layer thicknesses (whatever they may be, you
could be sweeping through these thicknesses or optimizing them and then you won’t
know what the particular value will be ahead of time)</li>
<li>Sum them all</li>
<li>Add 3 for some reason</li>
<li>Multiply the value of the sum by two (notice the extra outer parentheses)</li>
<li>Set max depth to the result</li>
</ol>
<p>This is super handy when for example you want your shell to be 30 nm thick (i.e
shell_radius = core_radius + 30 nm)</p>
</div>
<div class="section" id="postprocessing">
<h3>Postprocessing<a class="headerlink" href="#postprocessing" title="Permalink to this headline">¶</a></h3>
<p>The postprocessing section of the config file is pretty nifty. The structure
of this section is used to configure which postprocessing functions get called,
and what arguments they receive.</p>
<p>The headings immediately below the top level <code class="docutils literal"><span class="pre">Postprocessing</span></code> heading each
correspond to objects in <code class="docutils literal"><span class="pre">optics/postprocess.py</span></code>. Each of these objects
serve a specific purpose, detailed below</p>
<ul class="simple">
<li>Cruncher: Computes quantities that are specific to an individual simulation</li>
<li>Global_Cruncher: Computes global quantities for a group of simulations</li>
<li>Plotter: Plots things that are specific to an individual simulation</li>
<li>Global_Plotter: Plots global quantities for a group of simulations</li>
</ul>
<p>Underneath each of these 1st level object headings there exists a configuration
section that determines which methods of the object will get called, and with
which arguments they will be called. The level of headings beneath each object
correspond to the name of a method defined within that object. The string here
is very important, as it corresponds <em>exactly</em> to the name of a method of the
parent object in <code class="docutils literal"><span class="pre">postprocess.py</span></code>. Any typos mean the method won’t get called
properly.  Beneath the method name, the <code class="docutils literal"><span class="pre">compute</span></code> flag just determines
whether or not the function will get called so you can quickly turn things off
and on. The <code class="docutils literal"><span class="pre">args</span></code> flag determines what arguments get passed to the method.
This must be entered as a list for python’s argument expansion operators to
work. You can specify a single list, meaning only a single set of arguments
will be passed to the function. You can also specify a list of lists, meaning
the function will get called multiple times with multiple sets of arguments.
The order of the arguments is super important, and you need to make sure you
check the function signature of the method in <code class="docutils literal"><span class="pre">postprocess.py</span></code> to get the
order of the arguments correct. Accidentally swapping arguments can cause weird
things to happen.</p>
<p>Overall, this system is a little bit delicate but really nicely allows you to
rapidly and completely automatically compute and plot a bunch of interesting
things without having to modify any code.</p>
<p>NOTE: I might be changing the design of the postprocessing code really soon. It
currently doesn’t allow me to run postprocessing functions in parallel, which
slows things down a lot. I’m basically using each of these objects as a big
dictionary for methods, so I might literally switch to a “dispatcher” approach
where I store module-level functions in a big dictionary instead of inside
objects. This will be a long term fix that will ocurr on a separate branch so
don’t worry about it for now.</p>
</div>
</div>
<div class="section" id="useage">
<h2>Useage<a class="headerlink" href="#useage" title="Permalink to this headline">¶</a></h2>
<p>Ok, so that covers the input YAML file. Now, how do we actually use it? This is
the easy part! Most of the work is in configuring your simulation. Once you’ve
got your file set up, to run your simulation(s) simply execute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">sim_wrapper</span><span class="o">.</span><span class="n">py</span> <span class="n">your_input</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>That might take awhile, and you’ll see a bunch of log messages printed to your
terminal. Using the <code class="docutils literal"><span class="pre">postprocess.py</span></code> script is a bit more complicated. If you
ever forget what to do, execute:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python3</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">postprocess</span><span class="o">.</span><span class="n">py</span> <span class="o">--</span><span class="n">help</span>
</pre></div>
</div>
<p>Note we use python3 here. Annoyingly, S4 currently doesn’t support Python 3.
Python 3 has some nice features (like recursive globbing) that I take advantage
of in the postprocessing code, but can’t use in the <code class="docutils literal"><span class="pre">sim_wrapper.py</span></code> script.</p>
<p>Anyway, the help message will tell you what arguments you can pass in. Then
execute with:</p>
<div class="highlight-default"><div class="highlight"><pre><span></span><span class="n">python3</span> <span class="o">/</span><span class="n">path</span><span class="o">/</span><span class="n">to</span><span class="o">/</span><span class="n">postprocess</span><span class="o">.</span><span class="n">py</span> <span class="p">[</span><span class="n">args</span><span class="p">]</span> <span class="n">your_input</span><span class="o">.</span><span class="n">yml</span>
</pre></div>
</div>
<p>And that’s it!</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="Introduction.html">Introduction</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Tutorial</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#yaml-input-file">YAML Input File</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#types-of-parameters">Types of Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#fixed-parameters">Fixed Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#variable-parameters">Variable Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#optimized-parameters">Optimized Parameters</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-substition">Parameter Substition</a></li>
<li class="toctree-l3"><a class="reference internal" href="#parameter-evaluation">Parameter Evaluation</a></li>
<li class="toctree-l3"><a class="reference internal" href="#postprocessing">Postprocessing</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#useage">Useage</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="Code.html">Code</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="index.html">Documentation overview</a><ul>
      <li>Previous: <a href="Introduction.html" title="previous chapter">Introduction</a></li>
      <li>Next: <a href="Code.html" title="next chapter">Code</a></li>
  </ul></li>
</ul>
</div>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/Tutorial.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Kyle Robertson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
      |
      <a href="_sources/Tutorial.rst.txt"
          rel="nofollow">Page source</a>
    </div>

    

    
  </body>
</html>