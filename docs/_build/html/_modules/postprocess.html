<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>postprocess &#8212; Nanowire .1 documentation</title>
    
    <link rel="stylesheet" href="../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../',
        VERSION:     '.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../_static/jquery.js"></script>
    <script type="text/javascript" src="../_static/underscore.js"></script>
    <script type="text/javascript" src="../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="top" title="Nanowire .1 documentation" href="../index.html" />
    <link rel="up" title="Module code" href="index.html" />
   
  <link rel="stylesheet" href="../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body role="document">
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for postprocess</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">c</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">intg</span>
<span class="kn">import</span> <span class="nn">argparse</span> <span class="k">as</span> <span class="nn">ap</span>
<span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">copy</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">itertools</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">OrderedDict</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="c1"># Enables saving plots over ssh</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DISPLAY&#39;</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># plt.style.use([&#39;ggplot&#39;, &#39;paper&#39;])</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cmx</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="k">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1.inset_locator</span> <span class="k">import</span> <span class="n">zoomed_inset_axes</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1.inset_locator</span> <span class="k">import</span> <span class="n">mark_inset</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.axes_grid1</span> <span class="k">import</span> <span class="n">make_axes_locatable</span>
<span class="c1"># Literally just for the initial data load</span>
<span class="kn">import</span> <span class="nn">multiprocessing</span> <span class="k">as</span> <span class="nn">mp</span>
<span class="kn">import</span> <span class="nn">multiprocessing.dummy</span> <span class="k">as</span> <span class="nn">mpd</span>

<span class="kn">from</span> <span class="nn">utils.config</span> <span class="k">import</span> <span class="n">Config</span>
<span class="kn">from</span> <span class="nn">utils.simulation</span> <span class="k">import</span> <span class="n">Simulation</span>
<span class="kn">from</span> <span class="nn">utils.utils</span> <span class="k">import</span> <span class="n">configure_logger</span><span class="p">,</span> <span class="n">cmp_dicts</span><span class="p">,</span> <span class="n">open_atomic</span>

<span class="c1"># Configure module level logger if not running as main process</span>
<span class="k">if</span> <span class="ow">not</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">configure_logger</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="s1">&#39;INFO&#39;</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;postprocess&#39;</span><span class="p">,</span>
                              <span class="n">console</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="s1">&#39;logs/postprocess.log&#39;</span><span class="p">)</span>


<div class="viewcode-block" id="counted"><a class="viewcode-back" href="../postprocess.html#postprocess.counted">[docs]</a><span class="k">def</span> <span class="nf">counted</span><span class="p">(</span><span class="n">fn</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">wrapper</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">wrapper</span><span class="o">.</span><span class="n">called</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="k">return</span> <span class="n">fn</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">called</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="n">wrapper</span><span class="o">.</span><span class="n">__name__</span> <span class="o">=</span> <span class="n">fn</span><span class="o">.</span><span class="n">__name__</span>
    <span class="k">return</span> <span class="n">wrapper</span></div>


<div class="viewcode-block" id="Processor"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor">[docs]</a><span class="k">class</span> <span class="nc">Processor</span><span class="p">(</span><span class="nb">object</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Base data processor class that has some methods every other processor needs&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="p">[],</span> <span class="n">sim_groups</span><span class="o">=</span><span class="p">[],</span> <span class="n">failed_sims</span><span class="o">=</span><span class="p">[]):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;postprocess&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Processor base init&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span> <span class="o">=</span> <span class="n">global_conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="n">sims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span> <span class="o">=</span> <span class="n">sim_groups</span>
        <span class="c1"># A place to store any failed sims (i.e sims that are missing their</span>
        <span class="c1"># data file)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_sims</span> <span class="o">=</span> <span class="n">failed_sims</span>

<div class="viewcode-block" id="Processor.collect_sims"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.collect_sims">[docs]</a>    <span class="k">def</span> <span class="nf">collect_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Collect all the simulations beneath the base of the directory tree&quot;&quot;&quot;</span>
        <span class="c1"># Clear out the lists</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed_sims</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;text&#39;</span><span class="p">:</span>
            <span class="n">datfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.E&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">datfile</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_name&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;.E.npz&#39;</span>

        <span class="n">group_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">root</span><span class="p">,</span> <span class="n">dirs</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">os</span><span class="o">.</span><span class="n">walk</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_dir&#39;</span><span class="p">]):</span>
            <span class="k">if</span> <span class="s1">&#39;sim_conf.yml&#39;</span> <span class="ow">in</span> <span class="n">files</span> <span class="ow">and</span> <span class="n">datfile</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Gather sim at </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">root</span><span class="p">)</span>
                <span class="n">sim_obj</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span>
                    <span class="n">Config</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;sim_conf.yml&#39;</span><span class="p">)))</span>
                <span class="n">sim_obj</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">expand_vars</span><span class="p">()</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim_obj</span><span class="p">)</span>
                <span class="c1"># This retrieves the lowest node in the tree, stores that node</span>
                <span class="c1"># as the key and the list of sims beneath that node as values</span>
                <span class="n">parent_dir</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">dirname</span><span class="p">(</span><span class="n">root</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">parent_dir</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">group_dict</span><span class="p">:</span>
                    <span class="n">group_dict</span><span class="p">[</span><span class="n">parent_dir</span><span class="p">]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim_obj</span><span class="p">]</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">group_dict</span><span class="p">[</span><span class="n">parent_dir</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim_obj</span><span class="p">)</span>
            <span class="k">elif</span> <span class="s1">&#39;sim_conf.yml&#39;</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="n">sim_obj</span> <span class="o">=</span> <span class="n">Simulation</span><span class="p">(</span>
                    <span class="n">Config</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">root</span><span class="p">,</span> <span class="s1">&#39;sim_conf.yml&#39;</span><span class="p">)))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;The following sim is missing its data file: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                               <span class="n">sim_obj</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">])</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">failed_sims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim_obj</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">failed_sims</span></div>

<div class="viewcode-block" id="Processor.sort_sims"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.sort_sims">[docs]</a>    <span class="k">def</span> <span class="nf">sort_sims</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Sorts simulations by their parameters the way a human would. Called human sorting or</span>
<span class="sd">        natural sorting. Thanks stackoverflow&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_key</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Group paths before sorting: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span>
            <span class="n">group</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">sim_key</span><span class="p">)</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">group</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Group paths after sorting: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">paths</span><span class="p">))</span></div>

<div class="viewcode-block" id="Processor.get_param_vals"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.get_param_vals">[docs]</a>    <span class="k">def</span> <span class="nf">get_param_vals</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">parseq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Return all possible values of the provided parameter for this sweep&quot;&quot;&quot;</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">parseq</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">:</span>
                <span class="n">vals</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">val</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">vals</span></div>

<div class="viewcode-block" id="Processor.filter_by_param"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.filter_by_param">[docs]</a>    <span class="k">def</span> <span class="nf">filter_by_param</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">pars</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Accepts a dict where the keys are parameter names and the values are a list of possible</span>
<span class="sd">        values for that parameter. Any simulation whose parameter does not match any of the provided</span>
<span class="sd">        values is removed from the sims and sim_groups attribute&quot;&quot;&quot;</span>

        <span class="k">assert</span><span class="p">(</span><span class="nb">type</span><span class="p">(</span><span class="n">pars</span><span class="p">)</span> <span class="o">==</span> <span class="nb">dict</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">par</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">pars</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>
            <span class="n">groups</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
                <span class="n">filt_group</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span> <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">group</span> <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="ow">in</span> <span class="n">vals</span><span class="p">]</span>
                <span class="n">groups</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">filt_group</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="k">assert</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span></div>

<div class="viewcode-block" id="Processor.group_against"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.group_against">[docs]</a>    <span class="k">def</span> <span class="nf">group_against</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">variable_params</span><span class="p">,</span> <span class="n">sort_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Groups simulations by against particular parameter. Within each</span>
<span class="sd">        group, the parameter specified will vary, and all other</span>
<span class="sd">        parameters will remain fixed. Populates the sim_groups attribute and</span>
<span class="sd">        also returns a list of lists. The simulations with each group will be</span>
<span class="sd">        sorted in increasing order of the specified parameter. An optional key</span>
<span class="sd">        may be passed in, the groups will be sorted in increasing order of the</span>
<span class="sd">        specified key&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Grouping sims against: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="c1"># We need only need a shallow copy of the list containing all the sim objects</span>
        <span class="c1"># We don&#39;t want to modify the orig list but we wish to share the sim</span>
        <span class="c1"># objects the two lists contain</span>
        <span class="n">sims</span> <span class="o">=</span> <span class="n">copy</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">)</span>
        <span class="n">sim_groups</span> <span class="o">=</span> <span class="p">[[</span><span class="n">sims</span><span class="o">.</span><span class="n">pop</span><span class="p">()]]</span>
        <span class="c1"># While there are still sims that havent been assigned to a group</span>
        <span class="k">while</span> <span class="n">sims</span><span class="p">:</span>
            <span class="c1"># Get the comparison dict for this sim</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">sims</span><span class="o">.</span><span class="n">pop</span><span class="p">()</span>
            <span class="n">val1</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="c1"># We want the specified key to vary, so we remove it from the</span>
            <span class="c1"># comparison dict</span>
            <span class="k">del</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
            <span class="n">cmp1</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Simulation&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span>
                <span class="s1">&#39;Simulation&#39;</span><span class="p">],</span> <span class="s1">&#39;Layers&#39;</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">]}</span>
            <span class="n">match</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="c1"># Loop through each group, checking if this sim belongs in the</span>
            <span class="c1"># group</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">sim_groups</span><span class="p">:</span>
                <span class="n">sim2</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">val2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="k">del</span> <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
                <span class="n">cmp2</span> <span class="o">=</span> <span class="p">{</span><span class="s1">&#39;Simulation&#39;</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span>
                    <span class="s1">&#39;Simulation&#39;</span><span class="p">],</span> <span class="s1">&#39;Layers&#39;</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">]}</span>
                <span class="n">params_same</span> <span class="o">=</span> <span class="n">cmp_dicts</span><span class="p">(</span><span class="n">cmp1</span><span class="p">,</span> <span class="n">cmp2</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">params_same</span><span class="p">:</span>
                    <span class="n">match</span> <span class="o">=</span> <span class="kc">True</span>
                    <span class="c1"># We need to restore the param we removed from the</span>
                    <span class="c1"># configuration earlier</span>
                    <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span>
                    <span class="n">group</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val2</span>
            <span class="c1"># If we didnt find a matching group, we need to create a new group</span>
            <span class="c1"># for this simulation</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">match</span><span class="p">:</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">val1</span>
                <span class="n">sim_groups</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">sim</span><span class="p">])</span>
        <span class="c1"># Get the params that will define the path in the results dir for each</span>
        <span class="c1"># group that will be stored</span>
        <span class="n">ag_key</span> <span class="o">=</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">key</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">result_pars</span> <span class="o">=</span> <span class="p">[</span><span class="n">var</span> <span class="k">for</span> <span class="n">var</span> <span class="ow">in</span> <span class="n">variable_params</span> <span class="k">if</span> <span class="n">var</span> <span class="o">!=</span> <span class="n">ag_key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">sim_groups</span><span class="p">:</span>
            <span class="c1"># Sort the individual sims within a group in increasing order of</span>
            <span class="c1"># the parameter we are grouping against a</span>
            <span class="n">group</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">sim</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
            <span class="n">path</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">/grouped_against_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;treebase&#39;</span><span class="p">],</span>
                                                  <span class="n">ag_key</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span>
            <span class="c1"># If the only variable param is the one we grouped against, make</span>
            <span class="c1"># the top dir</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">result_pars</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                    <span class="k">pass</span>
            <span class="c1"># Otherwise make the top dir and all the subdirs</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">par</span> <span class="ow">in</span> <span class="n">result_pars</span><span class="p">:</span>
                    <span class="n">full_key</span> <span class="o">=</span> <span class="n">par</span> <span class="o">+</span> <span class="p">(</span><span class="s1">&#39;value&#39;</span><span class="p">,)</span>
                    <span class="c1"># All sims in the group will have the same values for</span>
                    <span class="c1"># result_pars so we can just use the first sim in the group</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">_</span><span class="si">{:.4E}</span><span class="s1">/&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">par</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">],</span>
                                                                  <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">full_key</span><span class="p">]))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;RESULTS DIR: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">path</span><span class="p">))</span>
                    <span class="k">try</span><span class="p">:</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">makedirs</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                    <span class="k">except</span> <span class="ne">OSError</span><span class="p">:</span>
                        <span class="k">pass</span>
            <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="n">group</span><span class="p">:</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">path</span>
        <span class="c1"># Sort the groups in increasing order of the provided sort key</span>
        <span class="k">if</span> <span class="n">sort_key</span><span class="p">:</span>
            <span class="n">sim_groups</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span> <span class="o">=</span> <span class="n">sim_groups</span>
        <span class="k">return</span> <span class="n">sim_groups</span></div>

<div class="viewcode-block" id="Processor.group_by"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.group_by">[docs]</a>    <span class="k">def</span> <span class="nf">group_by</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">sort_key</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Groups simulations by a particular parameter. Within each group, the</span>
<span class="sd">        parameter specified will remain fixed, and all other parameters will</span>
<span class="sd">        vary. Populates the sim_groups attribute and also returns a list of</span>
<span class="sd">        lists. The groups will be sorted in increasing order of the specified</span>
<span class="sd">        parameter. An optional key may be passed in, the individual sims within</span>
<span class="sd">        each group will be sorted in increasing order of the specified key&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Grouping sims by: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">key</span><span class="p">))</span>
        <span class="c1"># This works by storing the different values of the specifed parameter</span>
        <span class="c1"># as keys, and a list of sims whose value matches the key as the value</span>
        <span class="n">pdict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">in</span> <span class="n">pdict</span><span class="p">:</span>
                <span class="n">pdict</span><span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">pdict</span><span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="p">]</span>
        <span class="c1"># Now all the sims with matching values for the provided key are just</span>
        <span class="c1"># the lists located at each key. We sort the groups in increasing order</span>
        <span class="c1"># of the provided key</span>
        <span class="n">groups</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">pdict</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">group</span><span class="p">:</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">key</span><span class="p">])</span>
        <span class="c1"># If specified, sort the sims within each group in increasing order of</span>
        <span class="c1"># the provided sorting key</span>
        <span class="k">if</span> <span class="n">sort_key</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="n">groups</span><span class="p">:</span>
                <span class="n">group</span><span class="o">.</span><span class="n">sort</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="k">lambda</span> <span class="n">sim</span><span class="p">:</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="n">sort_key</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span> <span class="o">=</span> <span class="n">groups</span>
        <span class="k">return</span> <span class="n">groups</span></div>

<div class="viewcode-block" id="Processor.get_plane"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.get_plane">[docs]</a>    <span class="k">def</span> <span class="nf">get_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">xsamp</span><span class="p">,</span> <span class="n">ysamp</span><span class="p">,</span> <span class="n">zsamp</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a 1D array containing values for a 3D scalar field, reshapes</span>
<span class="sd">        the array into 3D and returns a 2D array containing the data on a given</span>
<span class="sd">        plane, for a specified index value (pval) of that plane. So, specifying</span>
<span class="sd">        plane=x and pval=30 would return data on the 30th y,z plane (a plane at</span>
<span class="sd">        the given x index). The number of samples (i.e data points) in each</span>
<span class="sd">        coordinate direction need not be equal&quot;&quot;&quot;</span>

        <span class="n">zsamp</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">zsamp</span><span class="p">)</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zsamp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xsamp</span><span class="p">,</span> <span class="n">ysamp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="n">pval</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pval</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">pval</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Processor.get_line"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.get_line">[docs]</a>    <span class="k">def</span> <span class="nf">get_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">arr</span><span class="p">,</span> <span class="n">xsamp</span><span class="p">,</span> <span class="n">ysamp</span><span class="p">,</span> <span class="n">zsamp</span><span class="p">,</span> <span class="n">line_dir</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a 1D array containing values for a 3D scalar field, reshapes</span>
<span class="sd">        the array into 3D and returns a new 1D array containing the data on a</span>
<span class="sd">        line in a given direction, for a specified index value for the other</span>
<span class="sd">        two spatial coordinates. So, specifying line_dir=z and c1=5,c2=5 would</span>
<span class="sd">        return all the data along the z-direction at the 5th x,y index. Note</span>
<span class="sd">        coordinates c1,c2 must always be specified in (x,y,z) order&quot;&quot;&quot;</span>

        <span class="n">scalar</span> <span class="o">=</span> <span class="n">arr</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">zsamp</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">xsamp</span><span class="p">,</span> <span class="n">ysamp</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">c2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">c1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">]</span></div>

<div class="viewcode-block" id="Processor.process"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Retrieves data for a particular simulation, then processes that</span>
<span class="sd">        data&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div>

<div class="viewcode-block" id="Processor.process_all"><a class="viewcode-back" href="../postprocess.html#postprocess.Processor.process_all">[docs]</a>    <span class="k">def</span> <span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Processes all the sims collected and stored in self.sims and</span>
<span class="sd">        self.sim_groups&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span></div></div>


<div class="viewcode-block" id="Cruncher"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher">[docs]</a><span class="k">class</span> <span class="nc">Cruncher</span><span class="p">(</span><span class="n">Processor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Crunches all the raw data. Calculates quantities specified in the global</span>
<span class="sd">    config file and either appends them to the existing data files or creates</span>
<span class="sd">    new ones as needed&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="p">[],</span> <span class="n">sim_groups</span><span class="o">=</span><span class="p">[],</span> <span class="n">failed_sims</span><span class="o">=</span><span class="p">[]):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Cruncher</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;This is THE CRUNCHER!!!!!&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Cruncher.calculate"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.calculate">[docs]</a>    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">result</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)(</span><span class="n">sim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unable to calculate the following quantity: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">quantity</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Cruncher.process"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="n">sim_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Crunching data for sim </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sim_path</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;SHAPE BEFORE CALCULATING: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">failed</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Following simulation missing data: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sim_path</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">failed_sims</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># For each quantity</span>
            <span class="k">for</span> <span class="n">quant</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Cruncher&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;compute&#39;</span><span class="p">]:</span>
                    <span class="n">argsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing </span><span class="si">%s</span><span class="s1"> with args </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                                  <span class="nb">str</span><span class="p">(</span><span class="n">quant</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">argsets</span><span class="p">))</span>
                    <span class="k">if</span> <span class="n">argsets</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">argsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">argset</span> <span class="ow">in</span> <span class="n">argsets</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing individual argset&#39;</span>
                                          <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">argset</span><span class="p">))</span>
                            <span class="k">if</span> <span class="n">argset</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">argset</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="p">[])</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span>
                                <span class="s1">&#39;SHAPE AFTER CALCULATING: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">argsets</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">argsets</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="p">[])</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;SHAPE AFTER CALCULATING: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span>
                                       <span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;E lookup: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_lookup</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;H lookup: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">h_lookup</span><span class="p">))</span>

            <span class="n">sim</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="Cruncher.process_all"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.process_all">[docs]</a>    <span class="k">def</span> <span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Beginning data crunch ...&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;post_parallel&#39;</span><span class="p">]:</span>
            <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">num_procs</span> <span class="o">=</span> <span class="n">mp</span><span class="o">.</span><span class="n">cpu_count</span><span class="p">()</span> <span class="o">-</span> \
                <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;reserved_cores&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;Crunching sims in parallel using </span><span class="si">%s</span><span class="s1"> cores ...&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">num_procs</span><span class="p">))</span>
            <span class="n">pool</span> <span class="o">=</span> <span class="n">mpd</span><span class="o">.</span><span class="n">Pool</span><span class="p">(</span><span class="n">processes</span><span class="o">=</span><span class="n">num_procs</span><span class="p">)</span>
            <span class="n">pool</span><span class="o">.</span><span class="n">map</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">)</span></div>

<div class="viewcode-block" id="Cruncher.normE"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.normE">[docs]</a>    <span class="k">def</span> <span class="nf">normE</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate and returns the norm of E&quot;&quot;&quot;</span>

        <span class="c1"># Get the magnitude of E and add it to our data</span>
        <span class="n">E_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="n">E_mag</span> <span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">E_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">E_mag</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span> <span class="n">E_mag</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E_mag</span></div>

<div class="viewcode-block" id="Cruncher.normEsquared"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.normEsquared">[docs]</a>    <span class="k">def</span> <span class="nf">normEsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates and returns normE squared&quot;&quot;&quot;</span>

        <span class="c1"># Get the magnitude of E and add it to our data</span>
        <span class="n">E_magsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="n">E_magsq</span> <span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normEsquared&#39;</span><span class="p">,</span> <span class="n">E_magsq</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E_magsq</span></div>

<div class="viewcode-block" id="Cruncher.normH"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.normH">[docs]</a>    <span class="k">def</span> <span class="nf">normH</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate and returns the norm of H&quot;&quot;&quot;</span>

        <span class="c1"># Get the magnitude of H and add it to our data. This loops through</span>
        <span class="c1"># each components real and imaginary parts and squares them (which is</span>
        <span class="c1"># what would happen if you took the complex number for each component</span>
        <span class="c1"># and multiplied it by its conjugate).</span>
        <span class="n">H_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="n">H_mag</span> <span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">H_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">H_mag</span><span class="p">)</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normH&#39;</span><span class="p">,</span> <span class="n">H_mag</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_mag</span></div>

<div class="viewcode-block" id="Cruncher.normHsquared"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.normHsquared">[docs]</a>    <span class="k">def</span> <span class="nf">normHsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates and returns the norm of H squared&quot;&quot;&quot;</span>

        <span class="n">H_magsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">6</span><span class="p">):</span>
            <span class="n">H_magsq</span> <span class="o">+=</span> <span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="p">[:,</span> <span class="n">i</span><span class="p">]</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normHsquared&#39;</span><span class="p">,</span> <span class="n">H_magsq</span><span class="p">,</span> <span class="s2">&quot;H&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_magsq</span></div>

<div class="viewcode-block" id="Cruncher.get_nk"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.get_nk">[docs]</a>    <span class="k">def</span> <span class="nf">get_nk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns functions to compute index of refraction components n and k at a given</span>
<span class="sd">        frequency&quot;&quot;&quot;</span>
        <span class="c1"># Get data</span>
        <span class="n">freq_vec</span><span class="p">,</span> <span class="n">n_vec</span><span class="p">,</span> <span class="n">k_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Get n and k at specified frequency via interpolation</span>
        <span class="n">f_n</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">freq_vec</span><span class="p">,</span> <span class="n">n_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="n">f_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">freq_vec</span><span class="p">,</span> <span class="n">k_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f_n</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">f_k</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_circle_nk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns a 2D matrix containing the N,K values at each point in space</span>
<span class="sd">        for a circular in-plane geometry&quot;&quot;&quot;</span>
        <span class="c1"># Set up the parameters</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">rad</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="n">rad_sq</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">rad</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;material&#39;</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Build the matrix</span>
        <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">xi</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">cx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">yi</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">rad_sq</span><span class="p">:</span>
                    <span class="n">nk_mat</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="p">[</span><span class="n">mat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">mat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nk_mat</span>

    <span class="k">def</span> <span class="nf">_genrate_nk_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the nk profile in a layer with a nontrivial internal</span>
<span class="sd">        geometry. Returns a 2D matrix containing the product of n and k at each</span>
<span class="sd">        point</span>
<span class="sd">        lname: Name of the layer as a string</span>
<span class="sd">        ldata: This dict containing all the data for this layer</span>
<span class="sd">        nk: A dictionary with the material name as the key an a tuple</span>
<span class="sd">        containing (n,k) as the value</span>
<span class="sd">        samps: A tuple/list containing the number of sampling points in each</span>
<span class="sd">        spatial direction in (x,y,z) order</span>
<span class="sd">        steps: Same as samps but instead contains the step sizes in each</span>
<span class="sd">        direction&quot;&quot;&quot;</span>
        <span class="c1"># Initialize the matrix with values for the base material</span>
        <span class="n">base_mat</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="n">lname</span><span class="p">][</span><span class="s1">&#39;base_material&#39;</span><span class="p">]</span>
        <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">nk</span><span class="p">[</span><span class="n">base_mat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">base_mat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Get the shapes sorted in increasing order</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="n">lname</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
        <span class="c1"># Loop through the layers. We want them in increasing order so the</span>
        <span class="c1"># smallest shape, which is contained within all the other shapes and</span>
        <span class="c1"># should override their nk values, goes last</span>
        <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span> <span class="ow">in</span> <span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                <span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_circle_nk</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Computing generation rate for layers&#39;</span>
                                          <span class="s1">&#39; with </span><span class="si">%s</span><span class="s1"> shapes is not currently supported&#39;</span> <span class="o">%</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
            <span class="c1"># Update the matrix with the values from this new shape. The update</span>
            <span class="c1"># array will contain nonzero values within the shape, and zero</span>
            <span class="c1"># everywhere else. This line updates the nk_mat with only the</span>
            <span class="c1"># nonzero from the update matrix, and leaves all other elements</span>
            <span class="c1"># untouched</span>
            <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">update</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">update</span><span class="p">,</span> <span class="n">nk_mat</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nk_mat</span>

<div class="viewcode-block" id="Cruncher.genRate"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.genRate">[docs]</a>    <span class="k">def</span> <span class="nf">genRate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="c1"># We need to compute normEsquared before we can compute the generation</span>
        <span class="c1"># rate</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">normEsq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="s1">&#39;normEsquared&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">normEsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normEsquared</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span>
            <span class="c1"># Make sure we don&#39;t compute it twice</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Cruncher&#39;</span><span class="p">][</span>
                    <span class="s1">&#39;normEsquared&#39;</span><span class="p">][</span><span class="s1">&#39;compute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Prefactor for generation rate. Note we gotta convert from m^3 to cm^3,</span>
        <span class="c1"># hence 1e6 factor</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">epsilon_0</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e6</span><span class="p">)</span>
        <span class="c1"># Get the indices of refraction at this frequency</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="p">{</span><span class="n">mat</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_nk</span><span class="p">(</span><span class="n">matpath</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span> <span class="k">for</span> <span class="n">mat</span><span class="p">,</span> <span class="n">matpath</span> <span class="ow">in</span>
              <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Materials&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">nk</span><span class="p">[</span><span class="s1">&#39;vacuum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
        <span class="c1"># Get spatial discretization</span>
        <span class="n">samps</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span><span class="p">)</span>
        <span class="c1"># Reshape into an actual 3D matrix. Rows correspond to different y fixed x, columns to fixed</span>
        <span class="c1"># y variable x, and each layer in depth is a new z value</span>
        <span class="n">normEsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">normEsq</span><span class="p">,</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">))</span>
        <span class="n">gvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">normEsq</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="c1"># Main loop to compute generation in each layer</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ordered_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ldata</span> <span class="ow">in</span> <span class="n">ordered_layers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get boundaries between layers and their starting and ending</span>
            <span class="c1"># indices</span>
            <span class="n">layer_t</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER T: </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">layer_t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer_t</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">layer_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev_tup</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">layer_t</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;START: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;END: </span><span class="si">%i</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">ldata</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;HAS GEOMETRY&#39;</span><span class="p">)</span>
                <span class="c1"># This function returns the N,K profile in that layer as a 2D</span>
                <span class="c1"># matrix. Each element contains the product of n and k at that</span>
                <span class="c1"># point, using the NK values for the appropriate material</span>
                <span class="n">nk_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genrate_nk_geometry</span><span class="p">(</span>
                    <span class="n">sim</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
                <span class="n">gvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> \
                    <span class="n">nk_mat</span> <span class="o">*</span> <span class="n">normEsq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Its just a simple slab</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;NO GEOMETRY&#39;</span><span class="p">)</span>
                <span class="n">lmat</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;base_material&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER MATERIAL: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">lmat</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MATERIAL n: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MATERIAL k: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">region</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">normEsq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;REGION SHAPE: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;REGION: &#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
                <span class="n">gvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">region</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;GEN RATE MATRIX: &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">gvec</span><span class="p">))</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="c1"># Reshape back to 1D array</span>
        <span class="n">gvec</span> <span class="o">=</span> <span class="n">gvec</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span> <span class="o">*</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;GVEC AFTER FLATTENING: &#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">gvec</span><span class="p">))</span>
        <span class="c1"># This approach is 4 times faster than np.column_stack()</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">==</span> <span class="nb">len</span><span class="p">(</span><span class="n">gvec</span><span class="p">))</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;genRate&#39;</span><span class="p">,</span> <span class="n">gvec</span><span class="p">,</span> <span class="s2">&quot;E&quot;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gvec</span></div>

<div class="viewcode-block" id="Cruncher.angularAvg"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.angularAvg">[docs]</a>    <span class="k">def</span> <span class="nf">angularAvg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Perform an angular average of some quantity for either the E or H field&quot;&quot;&quot;</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">quant</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="p">[])</span>
            <span class="n">quant</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
            <span class="c1"># Make sure we don&#39;t compute it twice</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Cruncher&#39;</span><span class="p">][</span>
                    <span class="n">quantity</span><span class="p">][</span><span class="s1">&#39;compute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Get spatial discretization</span>
        <span class="n">rsamp</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;r_samples&#39;</span><span class="p">]</span>
        <span class="n">thsamp</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;theta_samples&#39;</span><span class="p">]</span>
        <span class="c1"># Reshape into an actual 3D matrix. Rows correspond to different y fixed x, columns to fixed</span>
        <span class="c1"># y variable x, and each layer in depth is a new z value</span>
        <span class="n">values</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span>
            <span class="n">quant</span><span class="p">,</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">))</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="c1"># Maximum r value such that circle and square unit cell have equal area</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># Diff between rmax and unit cell boundary at point of maximum</span>
        <span class="c1"># difference</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">rmax</span> <span class="o">-</span> <span class="n">period</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># Extra indices we need to expand layers by</span>
        <span class="n">x_inds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">y_inds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">))</span>
        <span class="c1"># Use periodic BCs to extend the data in the x-y plane</span>
        <span class="n">ext_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span>
                            <span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">,</span> <span class="n">values</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">))</span>
        <span class="c1"># Left-Right extensions. This indexing madness extracts the slice we want, flips it along the correct dimension</span>
        <span class="c1"># then sticks in the correct spot in the extended array</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span>
                                                       <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Top-Bottom extensions</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Corners, slightly trickier</span>
        <span class="c1"># Top left</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[</span>
            <span class="p">:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Bottom left</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span>
                                                   <span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Top right</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span>
                                                   <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Bottom right</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span>
                                                   <span class="n">x_inds</span><span class="p">:,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Now the center</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">values</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># Extend the points arrays to include these new regions</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sim</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">sim</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">y_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])))</span>
        <span class="c1"># The points on which we have data</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># The points corresponding to &quot;rings&quot; in cylindrical coordinates. Note we construct these</span>
        <span class="c1"># rings around the origin so we have to shift them to actually correspond to the center of</span>
        <span class="c1"># the nanowire</span>
        <span class="n">rvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">rsamp</span><span class="p">)</span>
        <span class="n">thvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">thsamp</span><span class="p">)</span>
        <span class="n">cyl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rvec</span><span class="p">:</span>
            <span class="n">xring</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
            <span class="n">yring</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
            <span class="n">cyl_coords</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xring</span>
            <span class="n">cyl_coords</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yring</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
        <span class="n">cyl_coords</span> <span class="o">+=</span> <span class="n">period</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># For every z layer in the 3D matrix of our quantity</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ext_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">)))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">ext_vals</span><span class="p">:</span>
            <span class="n">interp_vals</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">cyl_coords</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">rings</span> <span class="o">=</span> <span class="n">interp_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">)))</span>
            <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">avgs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">avg</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">avgs</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Save to avgs dict for this sim</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">quantity</span> <span class="o">+</span> <span class="s1">&#39;_angularAvg&#39;</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">avgs</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgs</span>
        <span class="k">return</span> <span class="n">avgs</span></div>

<div class="viewcode-block" id="Cruncher.transmissionData"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.transmissionData">[docs]</a>    <span class="k">def</span> <span class="nf">transmissionData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes reflection, transmission, and absorbance&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing transmission data ...&#39;</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;fluxes.dat&#39;</span><span class="p">)</span>
        <span class="n">data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
            <span class="n">d</span> <span class="o">=</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">d</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
                <span class="n">els</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="n">key</span> <span class="o">=</span> <span class="n">els</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">els</span><span class="p">))</span>
        <span class="c1"># sorted_layers is an OrderedDict, and thus has the popitem method</span>
        <span class="n">sorted_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;SORTED LAYERS: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">sorted_layers</span><span class="p">))</span>
        <span class="n">first_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="c1"># self.log.info(&#39;FIRST LAYER: %s&#39;%str(first_layer))</span>
        <span class="c1"># An ordered dict is actually just a list of tuples so we can access</span>
        <span class="c1"># the key directly like so</span>
        <span class="n">first_name</span> <span class="o">=</span> <span class="n">first_layer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">last_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="c1"># Port at top of substrate</span>
        <span class="n">last_name</span> <span class="o">=</span> <span class="n">last_layer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="c1"># Port at bottom of substrate</span>
        <span class="c1"># last_name = last_layer[0]+&#39;_bottom&#39;</span>
        <span class="c1"># self.log.info(&#39;LAST LAYER: %s&#39;%str(last_layer))</span>
        <span class="c1"># p_inc = data[first_name][0]</span>
        <span class="c1"># p_ref = np.abs(data[first_name][1])</span>
        <span class="c1"># p_trans = data[last_name][0]</span>
        <span class="n">p_inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">p_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">p_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">last_name</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="n">data</span><span class="p">[</span><span class="n">last_name</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
        <span class="n">reflectance</span> <span class="o">=</span> <span class="n">p_ref</span> <span class="o">/</span> <span class="n">p_inc</span>
        <span class="n">transmission</span> <span class="o">=</span> <span class="n">p_trans</span> <span class="o">/</span> <span class="n">p_inc</span>
        <span class="n">absorbance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">reflectance</span> <span class="o">-</span> <span class="n">transmission</span>
        <span class="c1">#absorbance = 1 - reflectance</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">reflectance</span> <span class="o">+</span> <span class="n">transmission</span> <span class="o">+</span> <span class="n">absorbance</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reflectance </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">reflectance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Transmission </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">transmission</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Absorbance </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">absorbance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Total = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tot</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">reflectance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">transmission</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># assert(absorbance &gt;= 0)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">delta</span> <span class="o">&lt;</span> <span class="o">.</span><span class="mi">00001</span><span class="p">)</span>
        <span class="c1">#assert(reflectance &gt;= 0 and transmission &gt;= 0 and absorbance &gt;= 0)</span>
        <span class="n">outpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;ref_trans_abs.dat&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing transmission file&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Reflectance,Transmission,Absorbance</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">reflectance</span><span class="p">,</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">absorbance</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">reflectance</span><span class="p">,</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">absorbance</span></div>

<div class="viewcode-block" id="Cruncher.integrated_absorbtion"><a class="viewcode-back" href="../postprocess.html#postprocess.Cruncher.integrated_absorbtion">[docs]</a>    <span class="k">def</span> <span class="nf">integrated_absorbtion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the absorption of a layer by using the volume integral of the product of the</span>
<span class="sd">        imaginary part of the relative permittivity and the norm squared of the E field&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;There are some bugs in S4 and other reasons&#39;</span>
                                  <span class="s1">&#39; that this function doesnt work yet&#39;</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;integrated_absorption.dat&#39;</span><span class="p">)</span>
        <span class="n">inpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;energy_densities.dat&#39;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="c1"># TODO: Assuming incident amplitude and therefore incident power is</span>
        <span class="c1"># just 1 for now</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="o">-.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">epsilon_0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">inf</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="c1"># Remove header line</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Dict where key is layer name and value is list of length 2 containing real and</span>
            <span class="c1"># imaginary parts of energy density integral</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span>
                <span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Energy densities: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Layer, Absorption</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">absorb</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">absorb</span><span class="p">))</span></div></div>


<div class="viewcode-block" id="Global_Cruncher"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher">[docs]</a><span class="k">class</span> <span class="nc">Global_Cruncher</span><span class="p">(</span><span class="n">Cruncher</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Computes global quantities for an entire run, instead of local quantities for an individual</span>
<span class="sd">    simulation&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="p">[],</span> <span class="n">sim_groups</span><span class="o">=</span><span class="p">[],</span> <span class="n">failed_sims</span><span class="o">=</span><span class="p">[]):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Global_Cruncher</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;This is the global cruncher&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Global_Cruncher.calculate"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.calculate">[docs]</a>    <span class="k">def</span> <span class="nf">calculate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unable to calculate the following quantity: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">quantity</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Global_Cruncher.process_all"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.process_all">[docs]</a>    <span class="k">def</span> <span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="c1"># For each quantity</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Beginning global cruncher processing ...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">quant</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Global_Cruncher&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;compute&#39;</span><span class="p">]:</span>
                <span class="n">argsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing </span><span class="si">%s</span><span class="s1"> with args </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="nb">str</span><span class="p">(</span><span class="n">quant</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">argsets</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">argsets</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">argsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">argset</span> <span class="ow">in</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing individual argset&#39;</span>
                                      <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">argset</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">argset</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">argset</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="n">argsets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">calculate</span><span class="p">(</span><span class="n">quant</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="Global_Cruncher.diff_sq"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.diff_sq">[docs]</a>    <span class="k">def</span> <span class="nf">diff_sq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the magnitude of the difference vector squared between two vector fields at each</span>
<span class="sd">        point in space&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">size</span> <span class="o">!=</span> <span class="n">y</span><span class="o">.</span><span class="n">size</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s2">&quot;You have attempted to compare datasets with an unequal number of points!!!!&quot;</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>
        <span class="c1"># Calculate the magnitude of the difference vector SQUARED at each point in space</span>
        <span class="c1"># This is mag(vec(x) - vec(y))^2 at each point in space. This should be a 1D array</span>
        <span class="c1"># with # of elements = # sampling points</span>
        <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">((</span><span class="n">x</span> <span class="o">-</span> <span class="n">y</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">mag_diff_vec</span></div>

<div class="viewcode-block" id="Global_Cruncher.get_slice"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.get_slice">[docs]</a>    <span class="k">def</span> <span class="nf">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns indices for data that strip out air and substrate regions&quot;&quot;&quot;</span>
        <span class="c1"># TODO: This function is definitely not general. We need to get a list</span>
        <span class="c1"># of layers to exclude from the user. For now, just assume we want to</span>
        <span class="c1"># exclude the top and bottom regions</span>
        <span class="c1"># sorted_layers is an OrderedDict, and thus has the popitem method</span>
        <span class="n">sorted_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="n">first_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">last_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="c1"># We can get the starting and ending planes from their heights</span>
        <span class="n">start_plane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">first_layer</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                          <span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="n">start_plane</span> <span class="o">*</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="n">end_plane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">last_layer</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                        <span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">))</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">end_plane</span> <span class="o">*</span> <span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span></div>

<div class="viewcode-block" id="Global_Cruncher.get_comp_vec"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.get_comp_vec">[docs]</a>    <span class="k">def</span> <span class="nf">get_comp_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the comparison vector&quot;&quot;&quot;</span>
        <span class="c1"># Compare all other sims to our best estimate, which is sim with highest number of</span>
        <span class="c1"># basis terms (last in list cuz sorting)</span>

        <span class="c1"># Get the proper file extension depending on the field.</span>
        <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.E&#39;</span>
            <span class="c1"># Get the comparison vector</span>
            <span class="n">vec1</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
            <span class="n">normvec</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="s1">&#39;normE&#39;</span><span class="p">)</span>
            <span class="n">normvec</span> <span class="o">=</span> <span class="n">normvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
            <span class="n">ext</span> <span class="o">=</span> <span class="s1">&#39;.H&#39;</span>
            <span class="n">vec1</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">h_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
            <span class="n">normvec</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="s1">&#39;normH&#39;</span><span class="p">)</span>
            <span class="n">normvec</span> <span class="o">=</span> <span class="n">normvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                <span class="s1">&#39;The quantity for which you want to compute the error has not yet been calculated&#39;</span><span class="p">)</span>
            <span class="n">quit</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">vec1</span><span class="p">,</span> <span class="n">normvec</span><span class="p">,</span> <span class="n">ext</span></div>

<div class="viewcode-block" id="Global_Cruncher.local_error"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.local_error">[docs]</a>    <span class="k">def</span> <span class="nf">local_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the average of the local error between the vector fields of two simulations at</span>
<span class="sd">        each point in space&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Running the local error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="s1">&#39;localerror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing local error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
                <span class="c1"># Set the reference sim</span>
                <span class="n">ref_sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ref_sim</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                <span class="c1"># Get the comparison vector</span>
                <span class="n">vec1</span><span class="p">,</span> <span class="n">normvec</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span>
                    <span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="c1"># For all other sims in the groups, compare to best estimate</span>
                <span class="c1"># and write to error file</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">sim2</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">h_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing local error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                                  <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span>
                                      <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                                  <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                    <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                    <span class="c1"># in space</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;vec1 shape: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">vec1</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;vec2 shape: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">vec2</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                    <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
                    <span class="c1"># Normalize the magnitude squared of the difference vector by the magnitude squared of</span>
                    <span class="c1"># the local electric field of the comparison simulation at</span>
                    <span class="c1"># each point in space</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                        <span class="n">quit</span><span class="p">()</span>
                    <span class="n">norm_mag_diff</span> <span class="o">=</span> <span class="n">mag_diff_vec</span> <span class="o">/</span> <span class="n">normvec</span>
                    <span class="c1"># Compute the average of the normalized magnitude of all</span>
                    <span class="c1"># the difference vectors</span>
                    <span class="n">avg_diffvec_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span>
                        <span class="n">norm_mag_diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm_mag_diff</span><span class="o">.</span><span class="n">size</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">avg_diffvec_mag</span><span class="p">))</span>
                    <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                                  <span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">avg_diffvec_mag</span><span class="p">))</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
                <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="Global_Cruncher.global_error"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.global_error">[docs]</a>    <span class="k">def</span> <span class="nf">global_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the global error between the vector fields of two simulations. This is the sum</span>
<span class="sd">        of the magnitude squared of the difference vectors divided by the sum of the magnitude</span>
<span class="sd">        squared of the comparison efield vector over the desired section of the simulation cell&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Running the global error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="s1">&#39;globalerror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing global error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
                <span class="c1"># Set reference sim</span>
                <span class="n">ref_sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">ref_sim</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                <span class="c1"># Get the comparison vector</span>
                <span class="n">vec1</span><span class="p">,</span> <span class="n">normvec</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span>
                    <span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="c1"># For all other sims in the groups, compare to best estimate</span>
                <span class="c1"># and write to error file</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                    <span class="n">sim2</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">h_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing global error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                                  <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span>
                                      <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                                  <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                    <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                    <span class="c1"># in space</span>
                    <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
                    <span class="c1"># Check for equal lengths between norm array and diff mag</span>
                    <span class="c1"># array</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                        <span class="n">quit</span><span class="p">()</span>
                    <span class="c1"># Error as a percentage should be the square root of the ratio of sum of mag diff vec</span>
                    <span class="c1"># squared to mag efield squared</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normvec</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                    <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span>
                                  <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">error</span><span class="p">))</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
                <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="Global_Cruncher.adjacent_error"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.adjacent_error">[docs]</a>    <span class="k">def</span> <span class="nf">adjacent_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the global error between the vector fields of two simulations. This is the sum</span>
<span class="sd">        of the magnitude squared of the difference vectors divided by the sum of the magnitude</span>
<span class="sd">        squared of the comparison efield vector over the desired section of the simulation cell.</span>
<span class="sd">        This computes error between adjacent sims in a sweep through basis terms.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
            <span class="s1">&#39;Running the global error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dirs&#39;</span><span class="p">]</span>
            <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                <span class="n">base</span><span class="p">,</span> <span class="s1">&#39;adjacenterror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing adjacent error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
                <span class="c1"># For all other sims in the groups, compare to best estimate</span>
                <span class="c1"># and write to error file</span>
                <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                    <span class="c1"># Set reference sim</span>
                    <span class="n">ref_sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                    <span class="n">ref_sim</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                    <span class="c1"># Get the comparison vector</span>
                    <span class="n">vec1</span><span class="p">,</span> <span class="n">normvec</span><span class="p">,</span> <span class="n">ext</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span>
                        <span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                    <span class="n">sim2</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                    <span class="k">if</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;E&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">e_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="k">elif</span> <span class="n">field</span> <span class="o">==</span> <span class="s1">&#39;H&#39;</span><span class="p">:</span>
                        <span class="n">vec2</span> <span class="o">=</span> <span class="n">sim2</span><span class="o">.</span><span class="n">h_data</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="mi">3</span><span class="p">:</span><span class="mi">9</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing adjacent error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                                  <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span>
                                      <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                                  <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                    <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                    <span class="c1"># in space</span>
                    <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vec1</span><span class="p">,</span> <span class="n">vec2</span><span class="p">)</span>
                    <span class="c1"># Check for equal lengths between norm array and diff mag</span>
                    <span class="c1"># array</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span>
                            <span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                        <span class="n">quit</span><span class="p">()</span>
                    <span class="c1"># Error as a percentage should be the square root of the ratio of sum of mag diff vec</span>
                    <span class="c1"># squared to mag efield squared</span>
                    <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normvec</span><span class="p">))</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">error</span><span class="p">))</span>
                    <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span>
                                  <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">error</span><span class="p">))</span>
                    <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
                    <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="Global_Cruncher.scalar_reduce"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.scalar_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">scalar_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Combine a scalar quantity across all simulations in each group. If</span>
<span class="sd">        avg=False then a direct sum is computed, otherwise an average is</span>
<span class="sd">        computed&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing scalar reduction for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
            <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
            <span class="n">group_comb</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
            <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
            <span class="c1"># This approach is more memory efficient then building a 2D array</span>
            <span class="c1"># of all the data from each group and summing along an axis</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
                <span class="n">group_comb</span> <span class="o">+=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
                <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">avg</span><span class="p">:</span>
                <span class="n">group_comb</span> <span class="o">=</span> <span class="n">group_comb</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_avg_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>

            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
                <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group_comb</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;text&#39;</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">+=</span> <span class="s1">&#39;.crnch&#39;</span>
                <span class="n">np</span><span class="o">.</span><span class="n">savetxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group_comb</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid file type in config&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Global_Cruncher.fractional_absorbtion"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.fractional_absorbtion">[docs]</a>    <span class="k">def</span> <span class="nf">fractional_absorbtion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the fraction of the incident spectrum that is absorbed by</span>
<span class="sd">        the device. This is a unitless number, and its interpretation somewhat</span>
<span class="sd">        depends on the units you express the incident spectrum in. If you</span>
<span class="sd">        expressed your incident spectrum in photon number, this can be</span>
<span class="sd">        interpreted as the fraction of incident photons that were absorbed. If</span>
<span class="sd">        you expressed your incident spectrum in terms of power per unit area,</span>
<span class="sd">        then this can be interpreted as the fraction of incident power per unit</span>
<span class="sd">        area that gets absorbed. In summary, its the fraction of whatever you</span>
<span class="sd">        put in that is being absorbed by the device.&quot;&quot;&quot;</span>
        <span class="n">valuelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_dir&#39;</span><span class="p">]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;Computing fractional absorbtion for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="c1"># Assuming the sims have been grouped by frequency, sum over all of</span>
            <span class="c1"># them</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span>
                                     <span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;ref_trans_abs.dat&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
                <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span>
                <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
                <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth</span>
                <span class="c1"># Get solar power from chosen spectrum</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
                <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="c1"># Get p at wvlength by interpolation</span>
                <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
                <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
                <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
                <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span> <span class="o">*</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="c1"># Use Trapezoid rule to perform the integration. Note all the</span>
            <span class="c1"># necessary factors of the wavelength have already been included</span>
            <span class="c1"># above</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1">#Jsc = intg.simps(Jsc_vals,x=wvlgths,even=&#39;avg&#39;)</span>
            <span class="n">integrated_absorbtion</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span><span class="p">)</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span><span class="p">)</span>
            <span class="c1"># factor of 1/10 to convert A*m^-2 to mA*cm^-2</span>
            <span class="c1">#wv_fact = c.e/(c.c*c.h*10)</span>
            <span class="c1">#wv_fact = .1</span>
            <span class="c1">#Jsc = (Jsc*wv_fact)/power</span>
            <span class="n">frac_absorb</span> <span class="o">=</span> <span class="n">integrated_absorbtion</span> <span class="o">/</span> <span class="n">power</span>
            <span class="n">outf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;fractional_absorbtion.dat&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">frac_absorb</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fractional Absorbtion = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">frac_absorb</span><span class="p">)</span>
            <span class="n">valuelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">frac_absorb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">valuelist</span></div>

<div class="viewcode-block" id="Global_Cruncher.Jsc"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.Jsc">[docs]</a>    <span class="k">def</span> <span class="nf">Jsc</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes photocurrent density. This is just the integrated</span>
<span class="sd">        absorption scaled by a unitful factor. Assuming perfect carrier</span>
<span class="sd">        collection, meaning every incident photon gets converted to 1 collected</span>
<span class="sd">        electron, this factor is q/(hbar*c) which converts to a current per</span>
<span class="sd">        unit area&quot;&quot;&quot;</span>
        <span class="n">valuelist</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;Computing photocurrent density for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="c1"># Assuming the sims have been grouped by frequency, sum over all of</span>
            <span class="c1"># them</span>
            <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="n">group</span><span class="p">):</span>
                <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span>
                                     <span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;ref_trans_abs.dat&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
                <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span>
                <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
                <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth</span>
                <span class="c1"># Get solar power from chosen spectrum</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
                <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span>
                    <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                <span class="c1"># Get p at wvlength by interpolation</span>
                <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                            <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
                <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
                <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
                <span class="c1"># This is our integrand</span>
                <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span> <span class="o">*</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="c1"># Use Trapezoid rule to perform the integration. Note all the</span>
            <span class="c1"># necessary factors of the wavelength have already been included</span>
            <span class="c1"># above</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">integrated_absorbtion</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span>
            <span class="c1"># factor of 1/10 to convert A*m^-2 to mA*cm^-2</span>
            <span class="n">wv_fact</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">e</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
            <span class="n">Jsc</span> <span class="o">=</span> <span class="n">wv_fact</span> <span class="o">*</span> <span class="n">integrated_absorbtion</span>
            <span class="n">outf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;jsc.dat&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
                <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Jsc</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Jsc = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Jsc</span><span class="p">)</span>
            <span class="n">valuelist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">Jsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">valuelist</span></div>

<div class="viewcode-block" id="Global_Cruncher.weighted_transmissionData"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Cruncher.weighted_transmissionData">[docs]</a>    <span class="k">def</span> <span class="nf">weighted_transmissionData</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes spectrally weighted absorption,transmission, and reflection&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span>
                <span class="s1">&#39;Computing spectrally weighted transmission data for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
            <span class="n">abs_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">ref_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">trans_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="c1"># Get solar power from chosen spectrum</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
            <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">skiprows</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span>
                <span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="c1"># Get interpolating function for power</span>
            <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
            <span class="c1"># Assuming the leaves contain frequency values, sum over all of</span>
            <span class="c1"># them</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span>
                                     <span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;ref_trans_abs.dat&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
                <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span>
                <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
                <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth_nm</span>
                <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
                <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span>
                <span class="n">abs_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">absorb</span>
                <span class="n">ref_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">ref</span>
                <span class="n">trans_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">trans</span>
            <span class="c1"># Now integrate all the weighted spectra and divide by the power of</span>
            <span class="c1"># the spectra</span>
            <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">abs_vals</span> <span class="o">=</span> <span class="n">abs_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">ref_vals</span> <span class="o">=</span> <span class="n">ref_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">trans_vals</span> <span class="o">=</span> <span class="n">trans_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">power</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span>
            <span class="n">wght_ref</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ref_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
            <span class="n">wght_abs</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">abs_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
            <span class="n">wght_trans</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">trans_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
            <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;weighted_transmission_data.dat&#39;</span><span class="p">)</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Reflection, Transmission, Absorbtion</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">wght_ref</span><span class="p">,</span> <span class="n">wght_trans</span><span class="p">,</span> <span class="n">wght_abs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">wght_ref</span><span class="p">,</span> <span class="n">wght_trans</span><span class="p">,</span> <span class="n">wght_abs</span></div></div>


<div class="viewcode-block" id="Plotter"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter">[docs]</a><span class="k">class</span> <span class="nc">Plotter</span><span class="p">(</span><span class="n">Processor</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots all the things listed in the config file&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="p">[],</span> <span class="n">sim_groups</span><span class="o">=</span><span class="p">[],</span> <span class="n">failed_sims</span><span class="o">=</span><span class="p">[]):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Plotter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;This is the plotter&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Plotter.process"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.process">[docs]</a>    <span class="k">def</span> <span class="nf">process</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">get_data</span><span class="p">()</span>
        <span class="n">sim_path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting data for sim </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">sim_path</span><span class="p">)</span>
        <span class="c1"># For each plot</span>
        <span class="k">for</span> <span class="n">plot</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Plotter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;compute&#39;</span><span class="p">]:</span>
                <span class="n">argsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting </span><span class="si">%s</span><span class="s1"> with args </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="nb">str</span><span class="p">(</span><span class="n">plot</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">argsets</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">argsets</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">argsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">argset</span> <span class="ow">in</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting individual argset&#39;</span>
                                      <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">argset</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">argset</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">argset</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">argsets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="p">[])</span>
        <span class="n">sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="Plotter.process_all"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.process_all">[docs]</a>    <span class="k">def</span> <span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Beginning local plotter method ...&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">process</span><span class="p">(</span><span class="n">sim</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.gen_plot"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.gen_plot">[docs]</a>    <span class="k">def</span> <span class="nf">gen_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">)(</span><span class="n">sim</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1">#  self.log.error(&quot;Unable to plot the following quantity: %s&quot;,</span>
            <span class="c1">#                 plot,exc_info=True,stack_info=True)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unable to plot the following quantity: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">plot</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Plotter.draw_geometry_2d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.draw_geometry_2d">[docs]</a>    <span class="k">def</span> <span class="nf">draw_geometry_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function draws the layer boundaries and in-plane geometry on 2D</span>
<span class="sd">        heatmaps&quot;&quot;&quot;</span>
        <span class="c1"># TODO: If we want to make things general, this function could actually</span>
        <span class="c1"># get really complicated for several reasons.</span>
        <span class="c1"># 1. Each layer can have a unique in plane geometry. If we are plotting</span>
        <span class="c1"># an xy plane (plane = z, poor notation which should be fixed), we need</span>
        <span class="c1"># to identify which layer we are in so we can extract the geometry</span>
        <span class="c1"># 2. We need to be able to handle any in-plane geometry thrown at us</span>
        <span class="c1"># 3. If plotting an xz, yz plane (plane = x, plane = y), we need to</span>
        <span class="c1"># know which plane we are at so we can scale the cross-sectional width</span>
        <span class="c1"># of any geometric features appropriately. This will definitely</span>
        <span class="c1"># involved some seriously nontrivial geometry depending on what shape</span>
        <span class="c1"># we are dealing with, how its rotated, etc.</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Drawing capabilities are severely limited until I&#39;</span>
                         <span class="s1">&#39; figure out how to handle a general geometry&#39;</span><span class="p">)</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">cent</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="s1">&#39;NW_AlShell&#39;</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;core&#39;</span><span class="p">][</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
        <span class="n">core_rad</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="s1">&#39;NW_AlShell&#39;</span><span class="p">][</span>
            <span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;core&#39;</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">shell_rad</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="s1">&#39;NW_AlShell&#39;</span><span class="p">][</span>
                <span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="s1">&#39;shell&#39;</span><span class="p">][</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">shell_rad</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">plane</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;draw nanowire circle&#39;</span><span class="p">)</span>
            <span class="n">core</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                <span class="p">(</span><span class="n">cent</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">cent</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">radius</span><span class="o">=</span><span class="n">core_rad</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">core</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">shell_rad</span><span class="p">:</span>
                <span class="n">shell</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Circle</span><span class="p">(</span>
                    <span class="p">(</span><span class="n">cent</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">cent</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">radius</span><span class="o">=</span><span class="n">shell_rad</span><span class="p">,</span> <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
                <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">shell</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plane</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span> <span class="ow">or</span> <span class="n">plane</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">ordered_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
            <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ldata</span> <span class="ow">in</span> <span class="n">ordered_layers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="c1"># Get boundaries between layers and their starting and ending</span>
                <span class="c1"># indices</span>
                <span class="n">layer_t</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer_t</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">layer_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">layer</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_tup</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">layer_t</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">layer_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span>
                         <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">]</span>
                    <span class="n">label_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.25</span>
                    <span class="n">label_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">.</span><span class="mi">01</span>
                    <span class="k">if</span> <span class="n">layer</span> <span class="o">==</span> <span class="s1">&#39;NW_AlShell&#39;</span><span class="p">:</span>
                        <span class="n">txt</span> <span class="o">=</span> <span class="n">layer</span><span class="p">[</span><span class="mi">0</span><span class="p">:</span><span class="mi">2</span><span class="p">]</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="n">txt</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span> <span class="n">family</span><span class="o">=</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span>
                                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                    <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
                <span class="k">if</span> <span class="n">layer</span> <span class="o">==</span> <span class="s1">&#39;NW_AlShell&#39;</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">shell_rad</span><span class="p">:</span>
                        <span class="n">rads</span> <span class="o">=</span> <span class="p">(</span><span class="n">core_rad</span><span class="p">,</span> <span class="n">shell_rad</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">rads</span> <span class="o">=</span> <span class="p">(</span><span class="n">core_rad</span><span class="p">,)</span>
                    <span class="k">for</span> <span class="n">rad</span> <span class="ow">in</span> <span class="n">rads</span><span class="p">:</span>
                        <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="p">(</span><span class="n">cent</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">rad</span><span class="p">,</span> <span class="n">cent</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">rad</span><span class="p">):</span>
                            <span class="c1"># Need two locations w/ same x values</span>
                            <span class="n">xv</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="p">,</span> <span class="n">x</span><span class="p">]</span>
                            <span class="n">yv</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span>
                                  <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">end</span> <span class="o">*</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">]</span>
                            <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">xv</span><span class="p">,</span> <span class="n">yv</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                                 <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                            <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">ax_hand</span></div>

<div class="viewcode-block" id="Plotter.heatmap2d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.heatmap2d">[docs]</a>    <span class="k">def</span> <span class="nf">heatmap2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorsMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A general utility method for plotting a 2D heat map&quot;&quot;&quot;</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colorsMap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed</span><span class="p">:</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
                <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="mf">100.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
                <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
            <span class="c1"># cNorm = matplotlib.colors.LogNorm(vmin=np.amin(cs)+.001, vmax=np.amax(cs))</span>
            <span class="c1"># cNorm = matplotlib.colors.LogNorm(vmin=1e13, vmax=np.amax(cs))</span>
        <span class="n">scalarMap</span> <span class="o">=</span> <span class="n">cmx</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="c1">#  ax.pcolormesh(x, y, cs,cmap=cm,norm=cNorm,alpha=.5,linewidth=0)</span>
        <span class="c1">#  ax.pcolor(x, y,</span>
        <span class="c1">#          cs,cmap=cm,norm=cNorm,alpha=.5,linewidth=0,edgecolors=&#39;none&#39;)</span>
        <span class="c1"># ax.imshow(cs,cmap=cm,norm=cNorm,extent=[x.min(),x.max(),y.min(),y.max()],aspect=&#39;auto&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">,</span> <span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span> <span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span>
                  <span class="n">aspect</span><span class="o">=.</span><span class="mi">1</span><span class="p">)</span>
        <span class="c1"># ax_ins = zoomed_inset_axes(ax, 6, loc=1)</span>
        <span class="c1"># ax_ins.imshow(cs[75:100,:], extent=[x.min(), x.max(), .8, 1.4])</span>
        <span class="c1"># ax_ins.grid(False)</span>

        <span class="c1"># ax.matshow(cs,cmap=cm,norm=cNorm, aspect=&#39;auto&#39;)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">scalarMap</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="c1"># div = make_axes_locatable(ax)</span>
        <span class="c1"># zoom_ax = div.append_axes(&quot;right&quot;,size=&#39;100%&#39;, pad=.5)</span>
        <span class="c1"># zoom_ax.imshow(cs[75:100,:], extent=[x.min(), x.max(), .8, 1.4])</span>
        <span class="c1"># zoom_ax.grid(False)</span>
        <span class="c1"># cax = div.append_axes(&quot;right&quot;,size=&quot;100%&quot;,pad=.05)</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarMap</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_xlim</span><span class="p">()</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="mf">0.1</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">xaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlim</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylim</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">y</span><span class="p">)))</span>
        <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">ax</span><span class="o">.</span><span class="n">get_ylim</span><span class="p">()</span>
        <span class="c1"># print(&#39;START: %f&#39;%start)</span>
        <span class="c1"># print(&#39;END: %f&#39;%end)</span>
        <span class="n">ticks</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="n">end</span><span class="p">,</span> <span class="n">start</span> <span class="o">-</span> <span class="mf">0.2</span><span class="p">,</span> <span class="o">-</span><span class="mf">0.2</span><span class="p">)</span>
        <span class="n">ticks</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="c1"># ticks = np.arange(start,end,0.2)</span>
        <span class="c1"># ticks = np.arange(start,end,-0.2)</span>
        <span class="c1"># print(&#39;###### TICKS ######&#39;)</span>
        <span class="c1"># print(ticks)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticks</span><span class="p">(</span><span class="n">ticks</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">yaxis</span><span class="o">.</span><span class="n">set_ticklabels</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="nb">reversed</span><span class="p">(</span><span class="n">ticks</span><span class="p">)))</span>
        <span class="c1"># fig.suptitle(labels[3])</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_geometry_2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.plane_2d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.plane_2d">[docs]</a>    <span class="k">def</span> <span class="nf">plane_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a heatmap of a fixed 2D plane&quot;&quot;&quot;</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="c1"># Maps planes to an integer for extracting data</span>
        <span class="c1"># plane_table = {&#39;x&#39;: 0,&#39;y&#39;: 1,&#39;z&#39;:2}</span>
        <span class="c1"># Get the scalar values</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Retrieving scalar </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DATA SHAPE: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">scalar</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="c1"># Filter out any undesired data that isn&#39;t on the planes</span>
        <span class="c1">#mat = np.column_stack((sim.pos_inds[:,0],sim.pos_inds[:,1],sim.pos_inds[:,2],scalar))</span>
        <span class="c1">#planes = np.array([row for row in mat if row[plane_table[plane]] == pval])</span>
        <span class="c1">#self.log.debug(&quot;Planes shape: %s&quot;%str(planes.shape))</span>
        <span class="c1"># Get all unique values for x,y,z and convert them to actual values not indices</span>
        <span class="c1">#x,y,z = np.unique(planes[:,0])*dx,np.unique(planes[:,1])*dy,np.unique(planes[:,2])</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">wvlgth</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">E9</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Frequency = </span><span class="si">{:.4E}</span><span class="s1"> Hz, Wavelength = </span><span class="si">{:.2f}</span><span class="s1"> nm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">wvlgth</span><span class="p">)</span>
        <span class="c1"># Get the plane we wish to plot</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Retrieving plane ...&#39;</span><span class="p">)</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span>
                            <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting plane&#39;</span><span class="p">)</span>
        <span class="n">show</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_x.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_y.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_z.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.scatter3d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.scatter3d">[docs]</a>    <span class="k">def</span> <span class="nf">scatter3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">colorsMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A general utility method for scatter plots in 3D&quot;&quot;&quot;</span>
        <span class="c1">#fig = plt.figure(figsize=(8,6))</span>
        <span class="c1">#ax = fig.add_subplot(111,projection=&#39;3d&#39;)</span>
        <span class="c1">#colors = cm.hsv(E_mag/max(E_mag))</span>
        <span class="c1">#colmap = c.ScalarMappable(cmap=cm.hsv)</span>
        <span class="c1"># colmap.set_array(E_mag)</span>
        <span class="c1">#yg = ax.scatter(xs, ys, zs, c=colors, marker=&#39;o&#39;)</span>
        <span class="c1">#cb = fig.colorbar(colmap)</span>
        <span class="c1"># print(&quot;X SHAPE: %s&quot;%str(x.shape))</span>
        <span class="c1"># print(&quot;Y SHAPE: %s&quot;%str(y.shape))</span>
        <span class="c1"># print(&quot;Z SHAPE: %s&quot;%str(z.shape))</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colorsMap</span><span class="p">)</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
        <span class="n">scalarMap</span> <span class="o">=</span> <span class="n">cmx</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

        <span class="c1">#ax = Axes3D(fig)</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">scalarMap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">scalarMap</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarMap</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">ptype</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.full_3d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.full_3d">[docs]</a>    <span class="k">def</span> <span class="nf">full_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a full 3D plot of a specified scalar quantity&quot;&quot;&quot;</span>
        <span class="c1"># The data just tells you what integer grid point you are on. Not what actual x,y coordinate you</span>
        <span class="c1"># are at</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="c1"># Get the scalar</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;X [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="c1"># Now plot!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter3d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span>
                       <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;full_3d&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.planes_3d"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.planes_3d">[docs]</a>    <span class="k">def</span> <span class="nf">planes_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">xplane</span><span class="p">,</span> <span class="n">yplane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots some scalar quantity in 3D but only along specified x-z and y-z planes&quot;&quot;&quot;</span>
        <span class="n">xplane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xplane</span><span class="p">)</span>
        <span class="n">yplane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">yplane</span><span class="p">)</span>
        <span class="c1"># Get the scalar values</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="c1"># Get the data on the plane with a fixed x value. These means we&#39;ll</span>
        <span class="c1"># have changing (y, z) points</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span><span class="p">,</span>
                               <span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="n">xplane</span><span class="p">)</span>
        <span class="c1"># plt.figure()</span>
        <span class="c1"># plt.imshow(xdata)</span>
        <span class="c1"># plt.show()</span>
        <span class="c1"># z first cuz we want y to be changing before z to correspond with the</span>
        <span class="c1"># way numpy flattens arrays. Note this means y points will be in the</span>
        <span class="c1"># 2nd column</span>
        <span class="n">xplanepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">xdata</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">xplanexval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">xplane</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">))))</span>
        <span class="n">xplanedata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xplanepoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanexval</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanepoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanepoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">xdata</span>
        <span class="c1"># Same procedure for fixed y plane</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span><span class="p">,</span>
                               <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="n">yplane</span><span class="p">)</span>
        <span class="n">yplanepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">ydata</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">yplaneyval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">yplane</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">ydata</span><span class="p">))))</span>
        <span class="n">yplanedata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yplanepoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplanepoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplaneyval</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplanepoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ydata</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;X [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="c1"># Now stack them vertically and plot!</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xplanedata</span><span class="p">,</span> <span class="n">yplanedata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter3d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;planes_3d&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.line_plot"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.line_plot">[docs]</a>    <span class="k">def</span> <span class="nf">line_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a simple line plot&quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">ptype</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Plotter.fixed_line"><a class="viewcode-back" href="../postprocess.html#postprocess.Plotter.fixed_line">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a scalar quantity on a line along a the z direction at some pair of</span>
<span class="sd">        coordinates in the plane perpendicular to that direction&quot;&quot;&quot;</span>
        <span class="n">coord1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord1</span><span class="p">)</span>
        <span class="n">coord2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord2</span><span class="p">)</span>
        <span class="c1"># Get the scalar values</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="c1"># Filter out any undesired data that isn&#39;t on the planes</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span>
                             <span class="n">sim</span><span class="o">.</span><span class="n">z_samples</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">z</span>
        <span class="c1">#mat = np.column_stack((sim.pos_inds[:,0],sim.pos_inds[:,1],sim.pos_inds[:,2],scalar))</span>
        <span class="c1">#planes = np.array([row for row in mat if row[0] == coord1 and row[1] == coord2])</span>
        <span class="c1">#planes[:,0] = planes[:,0]*dx</span>
        <span class="c1">#planes[:,1] = planes[:,1]*dy</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">wvlgth</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="mi">1</span><span class="n">E9</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Frequency = </span><span class="si">{:.4E}</span><span class="s1"> Hz, Wavelength = </span><span class="si">{:.2f}</span><span class="s1"> nm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">wvlgth</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="n">ptype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_line_plot_</span><span class="si">%i</span><span class="s2">_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">pos_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Global_Plotter"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter">[docs]</a><span class="k">class</span> <span class="nc">Global_Plotter</span><span class="p">(</span><span class="n">Plotter</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Plots global quantities for an entire run that are not specific to a single simulation&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="o">=</span><span class="p">[],</span> <span class="n">sim_groups</span><span class="o">=</span><span class="p">[],</span> <span class="n">failed_sims</span><span class="o">=</span><span class="p">[]):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Global_Plotter</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="n">__init__</span><span class="p">(</span>
            <span class="n">global_conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Global plotter init&quot;</span><span class="p">)</span>

<div class="viewcode-block" id="Global_Plotter.process_all"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter.process_all">[docs]</a>    <span class="k">def</span> <span class="nf">process_all</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Beginning global plotter method ...&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">plot</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Global_Plotter&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;compute&#39;</span><span class="p">]:</span>
                <span class="n">argsets</span> <span class="o">=</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;args&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting </span><span class="si">%s</span><span class="s1"> with args </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span>
                              <span class="nb">str</span><span class="p">(</span><span class="n">plot</span><span class="p">),</span> <span class="nb">str</span><span class="p">(</span><span class="n">argsets</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">argsets</span> <span class="ow">and</span> <span class="nb">type</span><span class="p">(</span><span class="n">argsets</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">==</span> <span class="nb">list</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">argset</span> <span class="ow">in</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting individual argset&#39;</span>
                                      <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">argset</span><span class="p">))</span>
                        <span class="k">if</span> <span class="n">argset</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">argset</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="p">[])</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">argsets</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="n">argsets</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">gen_plot</span><span class="p">(</span><span class="n">plot</span><span class="p">,</span> <span class="p">[])</span></div>

<div class="viewcode-block" id="Global_Plotter.gen_plot"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter.gen_plot">[docs]</a>    <span class="k">def</span> <span class="nf">gen_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">,</span> <span class="n">args</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plot</span><span class="p">)(</span><span class="o">*</span><span class="n">args</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;Unable to plot the following quantity: </span><span class="si">%s</span><span class="s2">&quot;</span><span class="p">,</span>
                           <span class="n">plot</span><span class="p">,</span> <span class="n">exc_info</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">stack_info</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Global_Plotter.convergence"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter.convergence">[docs]</a>    <span class="k">def</span> <span class="nf">convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">err_type</span><span class="o">=</span><span class="s1">&#39;global&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the convergence of a field across all available simulations&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting convergence&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_dir&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>
                <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;localerror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
                <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;globalerror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;adjacent&#39;</span><span class="p">:</span>
                <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;adjacenterror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Attempting to plot an unsupported error type&#39;</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">ValueError</span>
            <span class="n">paths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">fglob</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">datf</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">datf</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                        <span class="n">lab</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                        <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                        <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
                <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;M.S.E of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of Fourier Terms&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
                <span class="c1"># plt.xticks(x,labels,rotation=&#39;vertical&#39;)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                    <span class="k">if</span> <span class="s1">&#39;_excluded&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                    <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">convergence_</span><span class="si">%s%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span>
                        <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="n">err_type</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">excluded</span><span class="p">)</span>
                    <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                    <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Global_Plotter.scalar_reduce"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter.scalar_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">scalar_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the result of a particular scalar reduction for each group&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="n">sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting scalar reduction of </span><span class="si">%s</span><span class="s1"> for quantity&#39;</span>
                          <span class="s1">&#39; </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">quantity</span><span class="p">))</span>
            <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
            <span class="n">zs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;z_samples&#39;</span><span class="p">]</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;x_samples&#39;</span><span class="p">]</span>
            <span class="n">xs</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">xs</span><span class="p">))</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;y_samples&#39;</span><span class="p">]</span>
            <span class="n">ys</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">float</span><span class="p">(</span><span class="n">ys</span><span class="p">))</span>
            <span class="n">max_depth</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span>
            <span class="n">period</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">dx</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="n">xs</span>
            <span class="n">dy</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="n">ys</span>
            <span class="n">dz</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="o">/</span> <span class="n">zs</span>
            <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">dx</span><span class="p">)</span>
            <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
            <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_depth</span> <span class="o">+</span> <span class="n">dz</span><span class="p">,</span> <span class="n">dz</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
                <span class="n">globstr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">base</span><span class="p">,</span> <span class="s1">&#39;scalar_reduce*_</span><span class="si">%s</span><span class="s1">.npy&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
                <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">globstr</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;text&#39;</span><span class="p">:</span>
                <span class="n">globstr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span>
                    <span class="n">base</span><span class="p">,</span> <span class="s1">&#39;scalar_reduce*_</span><span class="si">%s</span><span class="s1">.crnch&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
                <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">globstr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect file type in config&#39;</span><span class="p">)</span>
            <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Reduction of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
            <span class="k">for</span> <span class="n">datfile</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
                    <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datfile</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;text&#39;</span><span class="p">:</span>
                    <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">datfile</span><span class="p">,</span> <span class="n">group_comb</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect file type in config&#39;</span><span class="p">)</span>
                <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">xs</span><span class="p">,</span> <span class="n">ys</span><span class="p">,</span> <span class="n">zs</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_x.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">show</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                                   <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_y.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="n">show</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                                   <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
                <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
                    <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_z.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span>
                                   <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Global_Plotter.transmission_data"><a class="viewcode-back" href="../postprocess.html#postprocess.Global_Plotter.transmission_data">[docs]</a>    <span class="k">def</span> <span class="nf">transmission_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absorbance</span><span class="p">,</span> <span class="n">reflectance</span><span class="p">,</span> <span class="n">transmission</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot transmissions, absorption, and reflectance assuming leaves are frequency&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">group</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim_groups</span><span class="p">:</span>
            <span class="c1"># base = group[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
            <span class="n">base</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting transmission data for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
            <span class="c1"># Assuming the leaves contain frequency values, sum over all of</span>
            <span class="c1"># them</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">refl_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">trans_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="n">absorb_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">))</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">group</span><span class="p">)):</span>
                <span class="n">sim</span> <span class="o">=</span> <span class="n">group</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span>
                                     <span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;ref_trans_abs.dat&#39;</span><span class="p">)</span>
                <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">f</span><span class="p">:</span>
                    <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span>
                        <span class="nb">map</span><span class="p">(</span><span class="nb">float</span><span class="p">,</span> <span class="n">f</span><span class="o">.</span><span class="n">readlines</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)))</span>
                <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
                <span class="n">trans_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
                <span class="n">refl_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>
                <span class="n">absorb_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span>
            <span class="n">freqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freqs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mi">1</span><span class="n">e9</span>
            <span class="n">refl_l</span> <span class="o">=</span> <span class="n">refl_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">absorb_l</span> <span class="o">=</span> <span class="n">absorb_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">trans_l</span> <span class="o">=</span> <span class="n">trans_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
            <span class="k">if</span> <span class="n">absorbance</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting absorbance&#39;</span><span class="p">)</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">absorb_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Absorption&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">reflectance</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">refl_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Reflection&#39;</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">transmission</span><span class="p">:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">trans_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Transmission&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
            <span class="n">figp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;transmission_plots.pdf&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength (nm)&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figp</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>


<div class="viewcode-block" id="main"><a class="viewcode-back" href="../postprocess.html#postprocess.main">[docs]</a><span class="k">def</span> <span class="nf">main</span><span class="p">():</span>
    <span class="n">parser</span> <span class="o">=</span> <span class="n">ap</span><span class="o">.</span><span class="n">ArgumentParser</span><span class="p">(</span><span class="n">description</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;A wrapper around s4_sim.py to automate parameter</span>
<span class="s2">            sweeps, optimization, directory organization, postproccessing, etc.&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;config_file&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Absolute path to the INI file</span>
<span class="s2">    specifying how you want this wrapper to behave&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-nc&#39;</span><span class="p">,</span> <span class="s1">&#39;--no_crunch&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Do not perform crunching</span>
<span class="s2">            operations. Useful when data has already been crunched but new plots need to be</span>
<span class="s2">            generated&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-ngc&#39;</span><span class="p">,</span> <span class="s1">&#39;--no_gcrunch&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Do not</span>
<span class="s2">            perform global crunching operations. Useful when data has already been crunched but new plots need to be</span>
<span class="s2">            generated&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-np&#39;</span><span class="p">,</span> <span class="s1">&#39;--no_plot&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Do not perform plotting</span>
<span class="s2">            operations. Useful when you only want to crunch your data without plotting&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-ngp&#39;</span><span class="p">,</span> <span class="s1">&#39;--no_gplot&#39;</span><span class="p">,</span> <span class="n">action</span><span class="o">=</span><span class="s2">&quot;store_true&quot;</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Do not perform global plotting</span>
<span class="s2">            operations. Useful when you only want to crunch your data without plotting&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--log_level&#39;</span><span class="p">,</span> <span class="nb">type</span><span class="o">=</span><span class="nb">str</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="n">choices</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;debug&#39;</span><span class="p">,</span> <span class="s1">&#39;info&#39;</span><span class="p">,</span> <span class="s1">&#39;warning&#39;</span><span class="p">,</span> <span class="s1">&#39;error&#39;</span><span class="p">,</span> <span class="s1">&#39;critical&#39;</span><span class="p">],</span>
                        <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;Logging level for the run&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;--filter_by&#39;</span><span class="p">,</span> <span class="n">nargs</span><span class="o">=</span><span class="s1">&#39;*&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;List of parameters you wish to filter by,</span>
<span class="s2">            specified like: p1:v1,v2,v3 p2:v1,v2,v3&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-gb&#39;</span><span class="p">,</span> <span class="s1">&#39;--group_by&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The parameter you</span>
<span class="s2">            would like to group simulations by, specified as a dot separated path</span>
<span class="s2">            to the key in the config as: path.to.key.value&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">parser</span><span class="o">.</span><span class="n">add_argument</span><span class="p">(</span><span class="s1">&#39;-ga&#39;</span><span class="p">,</span> <span class="s1">&#39;--group_against&#39;</span><span class="p">,</span> <span class="n">help</span><span class="o">=</span><span class="s2">&quot;&quot;&quot;The parameter</span>
<span class="s2">            you would like to group against, specified as a dot separated path</span>
<span class="s2">            to the key in the config as: path.to.key.value&quot;&quot;&quot;</span><span class="p">)</span>
    <span class="n">args</span> <span class="o">=</span> <span class="n">parser</span><span class="o">.</span><span class="n">parse_args</span><span class="p">()</span>
    <span class="k">if</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isfile</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">config_file</span><span class="p">):</span>
        <span class="n">conf</span> <span class="o">=</span> <span class="n">Config</span><span class="p">(</span><span class="n">path</span><span class="o">=</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">abspath</span><span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">config_file</span><span class="p">))</span>
        <span class="n">conf</span><span class="o">.</span><span class="n">expand_vars</span><span class="p">()</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;The file you specified does not exist!&quot;</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="p">(</span><span class="n">args</span><span class="o">.</span><span class="n">group_by</span> <span class="ow">or</span> <span class="n">args</span><span class="o">.</span><span class="n">group_against</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Need to group sims somehow. A sensible value would&#39;</span>
                         <span class="s1">&#39; be by/against frequency&#39;</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
            <span class="n">group_by</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">group_by</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">group_ag</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">group_against</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">)</span>

    <span class="c1"># Configure logger</span>
    <span class="n">lfile</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;logs/postprocess.log&#39;</span><span class="p">)</span>
    <span class="n">logger</span> <span class="o">=</span> <span class="n">configure_logger</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">args</span><span class="o">.</span><span class="n">log_level</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="s1">&#39;postprocess&#39;</span><span class="p">,</span>
                              <span class="n">console</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">logfile</span><span class="o">=</span><span class="n">lfile</span><span class="p">)</span>
    <span class="c1"># Configure plotting style</span>
    <span class="k">try</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;style&#39;</span><span class="p">])</span>
    <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">style</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;ggplot&#39;</span><span class="p">)</span>
    <span class="c1"># Collect the sims once up here and reuse them later</span>
    <span class="n">proc</span> <span class="o">=</span> <span class="n">Processor</span><span class="p">(</span><span class="n">conf</span><span class="p">)</span>
    <span class="n">sims</span><span class="p">,</span> <span class="n">failed_sims</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">collect_sims</span><span class="p">()</span>
    <span class="c1"># First we need to group against if specified. Grouping against corresponds</span>
    <span class="c1"># to &quot;leaves&quot; in the tree</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">group_against</span><span class="p">:</span>
        <span class="n">sim_groups</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">group_against</span><span class="p">(</span><span class="n">group_ag</span><span class="p">,</span> <span class="n">conf</span><span class="o">.</span><span class="n">variable</span><span class="p">)</span>
    <span class="c1"># Next we group by. This corresponds to building the parent nodes for each</span>
    <span class="c1"># set of leaf groups</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">group_by</span><span class="p">:</span>
        <span class="n">sim_groups</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">group_by</span><span class="p">(</span><span class="n">group_by</span><span class="p">)</span>
    <span class="c1"># print(len(sim_groups))</span>
    <span class="c1"># print(group_ag)</span>
    <span class="c1"># print(conf.variable)</span>
    <span class="c1"># for group in proc.sim_groups:</span>
    <span class="c1">#     sim = group[0]</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         os.makedirs(sim.conf[&#39;General&#39;][&#39;results_dir&#39;])</span>
    <span class="c1">#     except OSError:</span>
    <span class="c1">#         pass</span>
    <span class="c1"># quit()</span>
    <span class="c1"># Filter if specified</span>
    <span class="k">if</span> <span class="n">args</span><span class="o">.</span><span class="n">filter_by</span><span class="p">:</span>
        <span class="n">filt_dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">item</span> <span class="ow">in</span> <span class="n">args</span><span class="o">.</span><span class="n">filter_by</span><span class="p">:</span>
            <span class="n">par</span><span class="p">,</span> <span class="n">vals</span> <span class="o">=</span> <span class="n">item</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;:&#39;</span><span class="p">)</span>
            <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="n">filt_dict</span><span class="p">[</span><span class="n">par</span><span class="p">]</span> <span class="o">=</span> <span class="n">vals</span>
        <span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Here is the filter dictionary: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">filt_dict</span><span class="p">)</span>
        <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span> <span class="o">=</span> <span class="n">proc</span><span class="o">.</span><span class="n">filter_by_param</span><span class="p">(</span><span class="n">filt_dict</span><span class="p">)</span>
    <span class="c1"># Now do all the work</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">no_crunch</span><span class="p">:</span>
        <span class="n">crunchr</span> <span class="o">=</span> <span class="n">Cruncher</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="n">crunchr</span><span class="o">.</span><span class="n">process_all</span><span class="p">()</span>
        <span class="c1"># for sim in crunchr.sims:</span>
        <span class="c1">#     crunchr.transmissionData(sim)</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">no_gcrunch</span><span class="p">:</span>
        <span class="n">gcrunchr</span> <span class="o">=</span> <span class="n">Global_Cruncher</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="n">gcrunchr</span><span class="o">.</span><span class="n">process_all</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">no_plot</span><span class="p">:</span>
        <span class="n">pltr</span> <span class="o">=</span> <span class="n">Plotter</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="n">pltr</span><span class="o">.</span><span class="n">process_all</span><span class="p">()</span>
    <span class="k">if</span> <span class="ow">not</span> <span class="n">args</span><span class="o">.</span><span class="n">no_gplot</span><span class="p">:</span>
        <span class="n">gpltr</span> <span class="o">=</span> <span class="n">Global_Plotter</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">sims</span><span class="p">,</span> <span class="n">sim_groups</span><span class="p">,</span> <span class="n">failed_sims</span><span class="p">)</span>
        <span class="c1"># gpltr.collect_sims()</span>
        <span class="n">gpltr</span><span class="o">.</span><span class="n">process_all</span><span class="p">()</span></div>


<span class="k">if</span> <span class="n">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span><span class="p">:</span>
    <span class="n">main</span><span class="p">()</span>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper"><div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../index.html">Documentation overview</a><ul>
  <li><a href="index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Kyle Robertson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.4.6</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.9</a>
      
    </div>

    

    
  </body>
</html>