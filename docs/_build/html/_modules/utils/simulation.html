
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>utils.simulation &#8212; Nanowire .1 documentation</title>
    
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../',
        VERSION:     '.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true,
        SOURCELINK_SUFFIX: '.txt'
      };
    </script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head>
  <body>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for utils.simulation</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">matplotlib</span>
<span class="k">try</span><span class="p">:</span>
    <span class="n">os</span><span class="o">.</span><span class="n">environ</span><span class="p">[</span><span class="s1">&#39;DISPLAY&#39;</span><span class="p">]</span>
<span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
    <span class="n">matplotlib</span><span class="o">.</span><span class="n">use</span><span class="p">(</span><span class="s1">&#39;Agg&#39;</span><span class="p">)</span>
<span class="kn">import</span> <span class="nn">matplotlib.pyplot</span> <span class="k">as</span> <span class="nn">plt</span>
<span class="c1"># plt.style.use([&#39;ggplot&#39;, &#39;paper&#39;])</span>
<span class="kn">from</span> <span class="nn">mpl_toolkits.mplot3d</span> <span class="k">import</span> <span class="n">Axes3D</span>
<span class="kn">import</span> <span class="nn">matplotlib.cm</span> <span class="k">as</span> <span class="nn">cmx</span>
<span class="kn">import</span> <span class="nn">matplotlib.lines</span> <span class="k">as</span> <span class="nn">mlines</span>
<span class="kn">import</span> <span class="nn">matplotlib.patches</span> <span class="k">as</span> <span class="nn">mpatches</span>
<span class="kn">import</span> <span class="nn">scipy.constants</span> <span class="k">as</span> <span class="nn">c</span>
<span class="kn">from</span> <span class="nn">scipy</span> <span class="k">import</span> <span class="n">interpolate</span>
<span class="kn">import</span> <span class="nn">scipy.integrate</span> <span class="k">as</span> <span class="nn">intg</span>
<span class="kn">import</span> <span class="nn">tables</span> <span class="k">as</span> <span class="nn">tb</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">MutableMapping</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="k">import</span> <span class="n">open_atomic</span>
<span class="kn">import</span> <span class="nn">time</span>
<span class="kn">import</span> <span class="nn">glob</span>
<span class="kn">import</span> <span class="nn">logging</span>
<span class="kn">import</span> <span class="nn">itertools</span>


<span class="k">class</span> <span class="nc">TransmissionData</span><span class="p">(</span><span class="n">tb</span><span class="o">.</span><span class="n">IsDescription</span><span class="p">):</span>
    <span class="n">layer</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">StringCol</span><span class="p">(</span><span class="mi">60</span><span class="p">,</span> <span class="n">pos</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
    <span class="n">reflection</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Float32Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">transmission</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Float32Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">absorption</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Float32Col</span><span class="p">(</span><span class="n">pos</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>


<div class="viewcode-block" id="DataManager"><a class="viewcode-back" href="../../utils.html#utils.simulation.DataManager">[docs]</a><span class="k">class</span> <span class="nc">DataManager</span><span class="p">(</span><span class="n">MutableMapping</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    The base class for all *DataManager objects. This purpose of this object is</span>
<span class="sd">    to manage retrieving data from some on-disk format and storing it in a</span>
<span class="sd">    dictionary for later retrieval (the _data dict). This object behaves like a</span>
<span class="sd">    dict, and overrides all the key dictionary special methods.</span>

<span class="sd">    Lazy-loading logic is implemented. When initialized, this object should</span>
<span class="sd">    populate the keys of _data with all data items available on disk without</span>
<span class="sd">    loading them, instead storing None as the value. An item is only actually</span>
<span class="sd">    retrieved from the on-disk format when it is requested.</span>

<span class="sd">    Lazy writing is implemented as well. The value corresponding to a given key</span>
<span class="sd">    is updated if and only if the attempted assignment value differs from the</span>
<span class="sd">    existing value. If so, the _updated dict stores True to indicate that data</span>
<span class="sd">    value has been updated. Upon writing, only update values are written to</span>
<span class="sd">    disk. DISCLAIMER: This doesn&#39;t actually work for the NPZ backend because</span>
<span class="sd">    IDK how to modify individual arrays within the archive.</span>

<span class="sd">    We don&#39;t use the object dict (i.e __dict__) to store the simulation</span>
<span class="sd">    data because I dont want to worry about having keys for certain pieces of</span>
<span class="sd">    data conflict with some attributes I might want to set on this object. It&#39;s</span>
<span class="sd">    slightly less memory efficient but not in a significant way.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_avgs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">conf</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">log</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_update_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">raise</span> <span class="ne">NotImplementedError</span>

    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Here is where the fancy lazy loading is implemented</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_load_data</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__setitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">value</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Check for equality of the existing item in the dict and the value</span>
<span class="sd">        passed in. If they are the same, don&#39;t bother updating the dict. If</span>
<span class="sd">        they are different, replace the existing item and register that this</span>
<span class="sd">        key has been updated in the _updated dict so we know to write it later</span>
<span class="sd">        on</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="c1"># np.array_equal is necessary in case we are dealing with numpy arrays</span>
        <span class="c1"># Elementwise comparison of arrays of different shape throws a</span>
        <span class="c1"># deprecation warning, and array_equal works on dicts and lists</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">unchanged</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array_equal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">],</span> <span class="n">value</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">unchanged</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">unchanged</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data in </span><span class="si">%s</span><span class="s1"> unchanged, not updating&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Updating </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">value</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">True</span>

    <span class="k">def</span> <span class="nf">__delitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="k">del</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">iter</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;returns simple dict representation of the mapping&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&#39;&#39;&#39;echoes class, id, &amp; reproducible representation in the REPL&#39;&#39;&#39;</span>
        <span class="k">return</span> <span class="s1">&#39;</span><span class="si">{}</span><span class="s1">, D(</span><span class="si">{}</span><span class="s1">)&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">super</span><span class="p">(</span><span class="n">DataManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__repr__</span><span class="p">(),</span>
                                  <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">__del__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Closes data file before being destroyed</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Closing data file&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div>


<div class="viewcode-block" id="HDF5DataManager"><a class="viewcode-back" href="../../utils.html#utils.simulation.HDF5DataManager">[docs]</a><span class="k">class</span> <span class="nc">HDF5DataManager</span><span class="p">(</span><span class="n">DataManager</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Data manager class for the HDF5 storage backend</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param :class:`~utils.config.Config`: Config object for the simulation</span>
<span class="sd">        that this DataManager will be managing data for</span>
<span class="sd">        :param log: A logger object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">HDF5DataManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="s1">&#39;sim.hdf5&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">open_file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">)</span>
        <span class="n">ID</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gpath</span> <span class="o">=</span> <span class="s1">&#39;/sim_</span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">ID</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">gobj</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="s1">&#39;Group&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_keys</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">_update_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to pull in keys for all the data items this simulation has stored</span>
<span class="sd">        on disk, without loading the actual items</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">child</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">gobj</span><span class="o">.</span><span class="n">_f_iter_nodes</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">_v_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">_v_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">child</span><span class="o">.</span><span class="n">_v_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">_v_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="n">child</span><span class="o">.</span><span class="n">_v_name</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Implements logic for loading data when the user asks for it by</span>
<span class="sd">        accessing the revelant key. This is only called from __getitem__</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">nodepath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">node</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">nodepath</span><span class="p">)</span>
        <span class="k">except</span> <span class="n">tb</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
            <span class="c1"># Maybe we just haven&#39;t computed transmission data yet</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;transmission_data&#39;</span><span class="p">:</span>
                <span class="k">return</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="n">tb</span><span class="o">.</span><span class="n">NoSuchNodeError</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tb</span><span class="o">.</span><span class="n">Array</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">node</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">node</span><span class="o">.</span><span class="n">read</span><span class="p">()</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">tb</span><span class="o">.</span><span class="n">Table</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;fluxes&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">):</span> <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
                                   <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">read</span><span class="p">()}</span>
            <span class="k">elif</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;transmission_data&#39;</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">decode</span><span class="p">(</span><span class="s1">&#39;utf-8&#39;</span><span class="p">):</span>
                                                       <span class="p">(</span><span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">tup</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
                                                       <span class="k">for</span> <span class="n">tup</span> <span class="ow">in</span> <span class="n">node</span><span class="o">.</span><span class="n">read</span><span class="p">()}</span>
                <span class="k">except</span> <span class="n">tb</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                    <span class="k">pass</span>

<div class="viewcode-block" id="HDF5DataManager.write_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.HDF5DataManager.write_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes all necessary data out to the HDF5 file</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Beginning HDF5 data writing procedure&#39;</span><span class="p">)</span>
        <span class="c1"># Filter out the original data so we don&#39;t resave it</span>
        <span class="n">black_list</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;fluxes&#39;</span><span class="p">,</span> <span class="s1">&#39;Ex&#39;</span><span class="p">,</span> <span class="s1">&#39;Ey&#39;</span><span class="p">,</span> <span class="s1">&#39;Ez&#39;</span><span class="p">,</span> <span class="s1">&#39;transmission_data&#39;</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">key</span><span class="p">,</span> <span class="n">arr</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">black_list</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="n">key</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing data for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">existing_arr</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">key</span><span class="p">)</span>
                    <span class="n">existing_arr</span><span class="p">[</span><span class="o">...</span><span class="p">]</span> <span class="o">=</span> <span class="n">arr</span>
                <span class="k">except</span> <span class="n">tb</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;compression&#39;</span><span class="p">]:</span>
                        <span class="n">filt</span> <span class="o">=</span> <span class="n">tb</span><span class="o">.</span><span class="n">Filters</span><span class="p">(</span><span class="n">complevel</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">complib</span><span class="o">=</span><span class="s1">&#39;blosc&#39;</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">create_carray</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">obj</span><span class="o">=</span><span class="n">arr</span><span class="p">,</span>
                                                  <span class="n">filters</span><span class="o">=</span><span class="n">filt</span><span class="p">,</span>
                                                  <span class="n">atom</span><span class="o">=</span><span class="n">tb</span><span class="o">.</span><span class="n">Atom</span><span class="o">.</span><span class="n">from_dtype</span><span class="p">(</span><span class="n">arr</span><span class="o">.</span><span class="n">dtype</span><span class="p">))</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">create_array</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="n">key</span><span class="p">,</span> <span class="n">arr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data for </span><span class="si">%s</span><span class="s1"> unchanged, not writing&#39;</span><span class="p">,</span> <span class="n">key</span><span class="p">)</span>
            <span class="n">num_rows</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">keys</span><span class="p">()))</span><span class="o">*</span><span class="mi">2</span>
        <span class="c1"># We need to handle transmission_data separately because it gets</span>
        <span class="c1"># saved into a table</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">_updated</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing transmission data&#39;</span><span class="p">)</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">tb_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">gpath</span> <span class="o">+</span> <span class="s1">&#39;/transmission_data&#39;</span>
                <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">get_node</span><span class="p">(</span><span class="n">tb_path</span><span class="p">,</span> <span class="n">classname</span><span class="o">=</span><span class="s1">&#39;Table&#39;</span><span class="p">)</span>
                <span class="c1"># If the table exists, clear it out</span>
                <span class="n">table</span><span class="o">.</span><span class="n">remove_rows</span><span class="p">(</span><span class="n">start</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
            <span class="k">except</span> <span class="n">tb</span><span class="o">.</span><span class="n">NoSuchNodeError</span><span class="p">:</span>
                <span class="n">table</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">create_table</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">gpath</span><span class="p">,</span> <span class="s1">&#39;transmission_data&#39;</span><span class="p">,</span>
                                                 <span class="n">description</span><span class="o">=</span><span class="n">TransmissionData</span><span class="p">,</span>
                                                 <span class="n">expectedrows</span><span class="o">=</span><span class="n">num_rows</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">port</span><span class="p">,</span> <span class="n">tup</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">row</span> <span class="o">=</span> <span class="n">table</span><span class="o">.</span><span class="n">row</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;layer&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">port</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;reflection&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;transmission&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
                <span class="n">row</span><span class="p">[</span><span class="s1">&#39;absorption&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">()</span>
            <span class="n">table</span><span class="o">.</span><span class="n">flush</span><span class="p">()</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Data for transmission_data unchanged, not writing&#39;</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="NPZDataManager"><a class="viewcode-back" href="../../utils.html#utils.simulation.NPZDataManager">[docs]</a><span class="k">class</span> <span class="nc">NPZDataManager</span><span class="p">(</span><span class="n">DataManager</span><span class="p">):</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="p">,</span> <span class="n">log</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param :class:`~utils.config.Config`: Config object for the simulation</span>
<span class="sd">        that this DataManager will be managing data for</span>
<span class="sd">        :param log: A logger object</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="nb">super</span><span class="p">(</span><span class="n">NPZDataManager</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">conf</span><span class="p">,</span> <span class="n">log</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_update_keys</span><span class="p">()</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                            <span class="s1">&#39;field_data.npz&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_update_keys</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">clear</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Used to pull in keys for all the data items this simulation has stored</span>
<span class="sd">        on disk, without loading the actual items</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="o">.</span><span class="n">files</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">clear</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">key</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>

    <span class="k">def</span> <span class="nf">_load_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">key</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Actually pulls data from disk out of the _dfile NPZ archive for the</span>
<span class="sd">        requested key and puts it in the self._data dict for later retrieval</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;fluxes&#39;</span> <span class="ow">or</span> <span class="n">key</span> <span class="o">==</span> <span class="s1">&#39;transmission_data&#39;</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="p">:</span>
                <span class="c1"># We have do so some weird stuff here to unpack the</span>
                <span class="c1"># dictionaries because np.savez sticks them in a 0D array for</span>
                <span class="c1"># some reason</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">==</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="p">[</span><span class="n">key</span><span class="p">][()]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_dfile</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>

<div class="viewcode-block" id="NPZDataManager.write_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.NPZDataManager.write_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes all the data in the _data dict to disk. Unfortunately numpy npz</span>
<span class="sd">        archives don&#39;t support setting individual items in the NPZArchive</span>
<span class="sd">        object (i.e _dfile) and only writing the changes, so if any data key</span>
<span class="sd">        has been updated we need to write the entire dict for now</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># TODO: Stop using .npz archives and make my own wrapper around a bunch</span>
        <span class="c1"># of individual npy files</span>

        <span class="c1"># Get the current path</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Writing data for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_name&#39;</span><span class="p">])</span>
        <span class="c1"># Save the headers and the data</span>
        <span class="k">with</span> <span class="n">open_atomic</span><span class="p">(</span><span class="n">fname</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_data</span><span class="p">)</span>
        <span class="c1"># Save any local averages we have computed</span>
        <span class="n">dpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;all.avg&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">open_atomic</span><span class="p">(</span><span class="n">dpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">savez_compressed</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">_avgs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="Simulation"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation">[docs]</a><span class="k">class</span> <span class="nc">Simulation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    An object that represents a simulation. It stores a DataManager object for</span>
<span class="sd">    managing the reading and writing of all data as an attribute. It also</span>
<span class="sd">    stores a Config object, which is a dict-like object representing the</span>
<span class="sd">    configuration for the simulation, as an attribute. Many of the methods are</span>
<span class="sd">    for performing calculations on the data.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">conf</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        :param :class:`~utils.config.Config`: Config object for this simulation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">conf</span> <span class="o">=</span> <span class="n">conf</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;postprocess&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_data_manager</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">failed</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">avgs</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="c1"># Compute and store dx, dy, dz at attributes</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;z_samples&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;x_samples&#39;</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;y_samples&#39;</span><span class="p">])</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">max_depth</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="n">max_depth</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="n">max_depth</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">get_height</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">dz</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">=</span> <span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">id</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">])</span>

    <span class="k">def</span> <span class="nf">_get_data_manager</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Factory function that instantiates the correct data manager object</span>
<span class="sd">        depending on the file type specified in the config</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">ftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">NPZDataManager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">HDF5DataManager</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid file type in config&#39;</span><span class="p">)</span>

<div class="viewcode-block" id="Simulation.write_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.write_data">[docs]</a>    <span class="k">def</span> <span class="nf">write_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Writes the data. This is a simple wrapper around the write_data()</span>
<span class="sd">        method of the DataManager object, with some code to compute the time it</span>
<span class="sd">        took to perform the write operation</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">start</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">write_data</span><span class="p">()</span>
        <span class="n">end</span> <span class="o">=</span> <span class="n">time</span><span class="o">.</span><span class="n">time</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Write time: </span><span class="si">%.2f</span><span class="s1"> seconds&#39;</span><span class="p">,</span> <span class="n">end</span> <span class="o">-</span> <span class="n">start</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.get_scalar_quantity"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.get_scalar_quantity">[docs]</a>    <span class="k">def</span> <span class="nf">get_scalar_quantity</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Retrieves the entire 3D matrix for some scalar quantity</span>

<span class="sd">        :param str quantity: The quantity you would like to retrive (ex: &#39;Ex&#39;</span>
<span class="sd">                             or &#39;normE&#39;)</span>
<span class="sd">        :return: A 3D numpy array of the specified quantity</span>
<span class="sd">        :raises KeyError: If the specified quantity does not exist in the data</span>
<span class="sd">                          dict</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Retrieving scalar quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">quantity</span><span class="p">))</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">quantity</span><span class="p">]</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;You attempted to retrieve a quantity that does not&#39;</span>
                           <span class="s1">&#39; exist in the data dict&#39;</span><span class="p">)</span>
            <span class="k">raise</span></div>

<div class="viewcode-block" id="Simulation.clear_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.clear_data">[docs]</a>    <span class="k">def</span> <span class="nf">clear_data</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Clears all the data attributes to free up memory&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">_update_keys</span><span class="p">(</span><span class="n">clear</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.extend_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.extend_data">[docs]</a>    <span class="k">def</span> <span class="nf">extend_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">new_data</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Adds a new key, value pair to the DataManager object</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">quantity</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s2">&quot;Quantity </span><span class="si">%s</span><span class="s2"> exists in matrix, updating&quot;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">quantity</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;Adding </span><span class="si">%s</span><span class="s1"> to data dict&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">quantity</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">quantity</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_data</span></div>

<div class="viewcode-block" id="Simulation.get_line"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.get_line">[docs]</a>    <span class="k">def</span> <span class="nf">get_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">line_dir</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets data along a line through the 3D data array for the given quantity</span>
<span class="sd">        along a given direction</span>

<span class="sd">        :param str line_dir: Any of &#39;x&#39;, &#39;y&#39;, or &#39;z&#39;. Determines the direction</span>
<span class="sd">        along which the line cut is taken, the other two coordinates remain</span>
<span class="sd">        fixed and are specified by c1 and c2.</span>
<span class="sd">        :param int c1: The integer index for the first fixed coordinate.</span>
<span class="sd">        Indexes are in x,y, z order so if line_dir=&#39;z&#39; then c1 corresponds to x</span>
<span class="sd">        :param int c2: The integer index for the second coordinate.</span>
<span class="sd">        :param str quantity: The quantity whose data array you wish to take a</span>
<span class="sd">        line cut through</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">c2</span><span class="p">,</span> <span class="p">:,</span> <span class="n">c1</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">c2</span><span class="p">,</span> <span class="n">c1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">line_dir</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="n">c1</span><span class="p">,</span> <span class="n">c2</span><span class="p">]</span></div>

<div class="viewcode-block" id="Simulation.get_plane"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.get_plane">[docs]</a>    <span class="k">def</span> <span class="nf">get_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets data along a 2D plane/slice through the 3D data array for a given</span>
<span class="sd">        quantity</span>

<span class="sd">        :param str plane: Any of &#39;xy&#39;, &#39;yz&#39;, or &#39;xz&#39;. Determines the plane</span>
<span class="sd">        along which the slice is taken</span>
<span class="sd">        :param int pval: The index along the final unspecified direction. If</span>
<span class="sd">        plane=&#39;xy&#39; then index would index along the z direction.</span>
<span class="sd">        :param str quantity: The quantity whose data array you wish to take a</span>
<span class="sd">        line cut through</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Retrieving plane for </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zy&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="n">pval</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zx&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pval</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yx&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">pval</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="Simulation.normE"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.normE">[docs]</a>    <span class="k">def</span> <span class="nf">normE</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates the norm of E. Adds it to the data dict for the simulation</span>
<span class="sd">        and also returns a 3D array</span>
<span class="sd">        :return: A 3D numpy array containing normE</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the magnitude of E and add it to our data</span>
        <span class="n">E_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Ex&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ex&#39;</span><span class="p">,</span> <span class="s1">&#39;Ey&#39;</span><span class="p">,</span> <span class="s1">&#39;Ez&#39;</span><span class="p">):</span>
            <span class="n">E_mag</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">comp</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normE&#39;</span><span class="p">,</span> <span class="n">E_mag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E_mag</span></div>

<div class="viewcode-block" id="Simulation.normEsquared"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.normEsquared">[docs]</a>    <span class="k">def</span> <span class="nf">normEsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Calculates and returns normE squared. Adds it to the data dict for</span>
<span class="sd">        the simulation and also returns a 3D array</span>
<span class="sd">        :return: A 3D numpy array containing normE squared</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get the magnitude of E and add it to our data</span>
        <span class="n">E_magsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Ex&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Ex&#39;</span><span class="p">,</span> <span class="s1">&#39;Ey&#39;</span><span class="p">,</span> <span class="s1">&#39;Ez&#39;</span><span class="p">):</span>
            <span class="n">E_magsq</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">comp</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normEsquared&#39;</span><span class="p">,</span> <span class="n">E_magsq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">E_magsq</span></div>

<div class="viewcode-block" id="Simulation.normH"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.normH">[docs]</a>    <span class="k">def</span> <span class="nf">normH</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculate and returns the norm of H&quot;&quot;&quot;</span>

        <span class="n">H_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Hx&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Hx&#39;</span><span class="p">,</span> <span class="s1">&#39;Hy&#39;</span><span class="p">,</span> <span class="s1">&#39;Hz&#39;</span><span class="p">):</span>
            <span class="n">H_mag</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">comp</span><span class="p">])</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normH&#39;</span><span class="p">,</span> <span class="n">H_mag</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_mag</span></div>

<div class="viewcode-block" id="Simulation.normHsquared"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.normHsquared">[docs]</a>    <span class="k">def</span> <span class="nf">normHsquared</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Calculates and returns the norm of H squared&quot;&quot;&quot;</span>

        <span class="n">H_magsq</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;Hx&#39;</span><span class="p">],</span> <span class="n">dtype</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;Hx&#39;</span><span class="p">,</span> <span class="s1">&#39;Hy&#39;</span><span class="p">,</span> <span class="s1">&#39;Hz&#39;</span><span class="p">):</span>
            <span class="n">H_magsq</span> <span class="o">+=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">comp</span><span class="p">])</span><span class="o">**</span><span class="mi">2</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normHsquared&#39;</span><span class="p">,</span> <span class="n">H_magsq</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">H_magsq</span></div>

<div class="viewcode-block" id="Simulation.get_nk"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.get_nk">[docs]</a>    <span class="k">def</span> <span class="nf">get_nk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">,</span> <span class="n">freq</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns n and k, the real and imaginary components of the index of refraction at a given</span>
<span class="sd">        frequency</span>
<span class="sd">        :param str path: A path to a text file containing the n and k data. The</span>
<span class="sd">        first column should be the frequency in Hertz, the second column the n</span>
<span class="sd">        values, and the third column the k values. Columns must be delimited</span>
<span class="sd">        by whitespace.</span>
<span class="sd">        :param float freq: The desired frequency in Hertz</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Get data</span>
        <span class="n">freq_vec</span><span class="p">,</span> <span class="n">n_vec</span><span class="p">,</span> <span class="n">k_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="c1"># Get n and k at specified frequency via interpolation</span>
        <span class="n">f_n</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">freq_vec</span><span class="p">,</span> <span class="n">n_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="n">f_k</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">freq_vec</span><span class="p">,</span> <span class="n">k_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                   <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">f_n</span><span class="p">(</span><span class="n">freq</span><span class="p">),</span> <span class="n">f_k</span><span class="p">(</span><span class="n">freq</span><span class="p">)</span></div>

    <span class="k">def</span> <span class="nf">_get_circle_nk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Returns a 2D matrix containing the N,K values at each point in space</span>
<span class="sd">        for a circular in-plane geometry</span>
<span class="sd">        :param dict sdata: The dictionary containing the parameters and info</span>
<span class="sd">        about this circle</span>
<span class="sd">        :param dict nk: The dict containing the n and k values for all the</span>
<span class="sd">        materials used in the sim. Keys are material names, values are tuples</span>
<span class="sd">        containing (n, k)</span>
<span class="sd">        :param tup samps: The number of samples taken in the (x, y) directions</span>
<span class="sd">        :param tup steps: The length of the spatial discretization step in the</span>
<span class="sd">        (x, y) directions</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Set up the parameters</span>
        <span class="n">cx</span><span class="p">,</span> <span class="n">cy</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">][</span><span class="s1">&#39;y&#39;</span><span class="p">]</span>
        <span class="n">rad</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="n">rad_sq</span> <span class="o">=</span> <span class="n">rad</span> <span class="o">*</span> <span class="n">rad</span>
        <span class="n">mat</span> <span class="o">=</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;material&#39;</span><span class="p">]</span>
        <span class="n">dx</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">dy</span> <span class="o">=</span> <span class="n">steps</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Build the matrix</span>
        <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">full</span><span class="p">((</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]),</span> <span class="n">np</span><span class="o">.</span><span class="n">nan</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">xi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]):</span>
            <span class="k">for</span> <span class="n">yi</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">]):</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="p">((</span><span class="n">xi</span> <span class="o">*</span> <span class="n">dx</span><span class="p">)</span> <span class="o">-</span> <span class="n">cx</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="o">+</span> <span class="p">((</span><span class="n">yi</span> <span class="o">*</span> <span class="n">dy</span><span class="p">)</span> <span class="o">-</span> <span class="n">cy</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span>
                <span class="k">if</span> <span class="n">dist</span> <span class="o">&lt;=</span> <span class="n">rad_sq</span><span class="p">:</span>
                    <span class="n">nk_mat</span><span class="p">[</span><span class="n">yi</span><span class="p">,</span> <span class="n">xi</span><span class="p">]</span> <span class="o">=</span> <span class="n">nk</span><span class="p">[</span><span class="n">mat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">mat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">nk_mat</span>

    <span class="k">def</span> <span class="nf">_genrate_nk_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">lname</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the nk profile in a layer with a nontrivial internal</span>
<span class="sd">        geometry. Returns a 2D matrix containing the product of n and k at each</span>
<span class="sd">        point</span>
<span class="sd">        :param str lname: Name of the layer as a string</span>
<span class="sd">        :param dict ldata: This dict containing all the data for this layer</span>
<span class="sd">        :param dict nk: A dictionary with the material name as the key an a tuple</span>
<span class="sd">        containing (n,k) as the value</span>
<span class="sd">        :param tup samps: A tuple/list containing the number of sampling points in each</span>
<span class="sd">        spatial direction in (x,y,z) order</span>
<span class="sd">        :param tup steps: Same as samps but instead contains the step sizes in each</span>
<span class="sd">        direction</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># Initialize the matrix with values for the base material</span>
        <span class="n">base_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="n">lname</span><span class="p">][</span><span class="s1">&#39;base_material&#39;</span><span class="p">]</span>
        <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">nk</span><span class="p">[</span><span class="n">base_mat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">base_mat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> \
            <span class="n">np</span><span class="o">.</span><span class="n">ones</span><span class="p">((</span><span class="n">samps</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">samps</span><span class="p">[</span><span class="mi">0</span><span class="p">]))</span>
        <span class="c1"># Get the shapes sorted in increasing order</span>
        <span class="n">shapes</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">][</span><span class="n">lname</span><span class="p">][</span><span class="s1">&#39;geometry&#39;</span><span class="p">])</span>
        <span class="c1"># Loop through the shapes. We want them in increasing order so the</span>
        <span class="c1"># smallest shape, which is contained within all the other shapes and</span>
        <span class="c1"># should override their nk values, goes last</span>
        <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span> <span class="ow">in</span> <span class="n">shapes</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                <span class="n">update</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_circle_nk</span><span class="p">(</span><span class="n">shape</span><span class="p">,</span> <span class="n">sdata</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;Computing generation rate for layers&#39;</span>
                                          <span class="s1">&#39; with </span><span class="si">%s</span><span class="s1"> shapes is not currently supported&#39;</span> <span class="o">%</span> <span class="n">sdata</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">])</span>
            <span class="c1"># Update the matrix with the values from this new shape. The update</span>
            <span class="c1"># array will contain nonzero values within the shape, and nan</span>
            <span class="c1"># everywhere else. This line updates the nk_mat with only the</span>
            <span class="c1"># not nans from the update matrix, and leaves all other elements</span>
            <span class="c1"># untouched</span>
            <span class="c1"># nk_mat = np.where(update != 0, update, nk_mat)</span>
            <span class="n">nk_mat</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">where</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">isnan</span><span class="p">(</span><span class="n">update</span><span class="p">),</span> <span class="n">nk_mat</span><span class="p">,</span> <span class="n">update</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">nk_mat</span>

<div class="viewcode-block" id="Simulation.genRate"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.genRate">[docs]</a>    <span class="k">def</span> <span class="nf">genRate</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes and returns the 3D matrix containing the generation rate.</span>
<span class="sd">        Returns in units of cm^-3</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="c1"># We need to compute normEsquared before we can compute the generation</span>
        <span class="c1"># rate</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">normEsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="s1">&#39;normEsquared&#39;</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="n">normEsq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">normEsquared</span><span class="p">()</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;normEsquared&#39;</span><span class="p">,</span> <span class="n">normEsq</span><span class="p">)</span>
            <span class="c1"># Make sure we don&#39;t compute it twice</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Cruncher&#39;</span><span class="p">][</span>
                    <span class="s1">&#39;normEsquared&#39;</span><span class="p">][</span><span class="s1">&#39;compute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Prefactor for generation rate. Note we gotta convert from m^3 to cm^3,</span>
        <span class="c1"># hence 1e6 factor</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">epsilon_0</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">hbar</span> <span class="o">*</span> <span class="mf">1e6</span><span class="p">)</span>
        <span class="c1"># Get the indices of refraction at this frequency</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">nk</span> <span class="o">=</span> <span class="p">{</span><span class="n">mat</span><span class="p">:</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">get_nk</span><span class="p">(</span><span class="n">matpath</span><span class="p">,</span> <span class="n">freq</span><span class="p">))</span> <span class="k">for</span> <span class="n">mat</span><span class="p">,</span> <span class="n">matpath</span> <span class="ow">in</span>
              <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Materials&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="n">nk</span><span class="p">[</span><span class="s1">&#39;vacuum&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">nk</span><span class="p">)</span>
        <span class="c1"># Get spatial discretization</span>
        <span class="n">samps</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span><span class="p">)</span>
        <span class="n">gvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros_like</span><span class="p">(</span><span class="n">normEsq</span><span class="p">)</span>
        <span class="n">steps</span> <span class="o">=</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="c1"># Main loop to compute generation in each layer</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="n">ordered_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ldata</span> <span class="ow">in</span> <span class="n">ordered_layers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># Get boundaries between layers and their starting and ending</span>
            <span class="c1"># indices</span>
            <span class="n">layer_t</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">layer</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER T: </span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">layer_t</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">layer_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">prev_tup</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">dist</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">layer_t</span>
                <span class="n">start</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;START: </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">start</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;END: </span><span class="si">%i</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">ldata</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;HAS GEOMETRY&#39;</span><span class="p">)</span>
                <span class="c1"># This function returns the N,K profile in that layer as a 2D</span>
                <span class="c1"># matrix. Each element contains the product of n and k at that</span>
                <span class="c1"># point, using the NK values for the appropriate material</span>
                <span class="n">nk_mat</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_genrate_nk_geometry</span><span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">nk</span><span class="p">,</span> <span class="n">samps</span><span class="p">,</span> <span class="n">steps</span><span class="p">)</span>
                <span class="n">gvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> \
                    <span class="n">nk_mat</span> <span class="o">*</span> <span class="n">normEsq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># Its just a simple slab</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;NO GEOMETRY&#39;</span><span class="p">)</span>
                <span class="n">lmat</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;base_material&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;LAYER MATERIAL: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">lmat</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MATERIAL n: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">0</span><span class="p">]))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;MATERIAL k: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">1</span><span class="p">]))</span>
                <span class="n">region</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> \
                    <span class="n">nk</span><span class="p">[</span><span class="n">lmat</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">normEsq</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;REGION SHAPE: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">region</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;REGION: &#39;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">region</span><span class="p">))</span>
                <span class="n">gvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">region</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;GEN RATE MATRIX: &#39;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">gvec</span><span class="p">))</span>
            <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">extend_data</span><span class="p">(</span><span class="s1">&#39;genRate&#39;</span><span class="p">,</span> <span class="n">gvec</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">gvec</span></div>

<div class="viewcode-block" id="Simulation.angularAvg"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.angularAvg">[docs]</a>    <span class="k">def</span> <span class="nf">angularAvg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Perform an angular average of some quantity for either the E or H field</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">try</span><span class="p">:</span>
            <span class="n">quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="nb">getattr</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)()</span>
            <span class="n">quant</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
            <span class="c1"># Make sure we don&#39;t compute it twice</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Postprocessing&#39;</span><span class="p">][</span><span class="s1">&#39;Cruncher&#39;</span><span class="p">][</span>
                    <span class="n">quantity</span><span class="p">][</span><span class="s1">&#39;compute&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
                <span class="k">pass</span>
        <span class="c1"># Get spatial discretization</span>
        <span class="n">rsamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;r_samples&#39;</span><span class="p">]</span>
        <span class="n">thsamp</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;theta_samples&#39;</span><span class="p">]</span>
        <span class="n">period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="c1"># Maximum r value such that circle and square unit cell have equal area</span>
        <span class="n">rmax</span> <span class="o">=</span> <span class="n">period</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
        <span class="c1"># Diff between rmax and unit cell boundary at point of maximum</span>
        <span class="c1"># difference</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">rmax</span> <span class="o">-</span> <span class="n">period</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># Extra indices we need to expand layers by</span>
        <span class="n">x_inds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">))</span>
        <span class="n">y_inds</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">ceil</span><span class="p">(</span><span class="n">delta</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">))</span>
        <span class="c1"># Use periodic BCs to extend the data in the x-y plane</span>
        <span class="n">ext_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">quant</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">quant</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span>
                             <span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">,</span> <span class="n">quant</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">+</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">),</span>
                            <span class="n">dtype</span><span class="o">=</span><span class="n">quant</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="c1"># Left-Right extensions. This indexing madness extracts the slice we</span>
        <span class="c1"># want, flips it along the correct dimension then sticks in the correct</span>
        <span class="c1"># spot in the extended array</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:,</span> <span class="p">:,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Top-Bottom extensions</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span>
                 <span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="p">:][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Corners, slightly trickier</span>
        <span class="c1"># Top left</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[</span>
            <span class="p">:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Bottom left</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span>
                                                   <span class="mi">2</span> <span class="o">*</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">:</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="p">:]</span>
        <span class="c1"># Top right</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span>
                                                   <span class="mi">0</span><span class="p">:</span><span class="n">x_inds</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Bottom right</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span><span class="n">x_inds</span><span class="p">:,</span> <span class="o">-</span><span class="n">y_inds</span><span class="p">:]</span> <span class="o">=</span> <span class="n">ext_vals</span><span class="p">[:,</span> <span class="o">-</span>
                                                   <span class="n">x_inds</span><span class="p">:,</span> <span class="o">-</span><span class="mi">2</span> <span class="o">*</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">][:,</span> <span class="p">:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Now the center</span>
        <span class="n">ext_vals</span><span class="p">[:,</span> <span class="n">x_inds</span><span class="p">:</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="n">y_inds</span><span class="p">:</span><span class="o">-</span><span class="n">y_inds</span><span class="p">]</span> <span class="o">=</span> <span class="n">quant</span><span class="p">[:,</span> <span class="p">:,</span> <span class="p">:]</span>
        <span class="c1"># Extend the points arrays to include these new regions</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">x_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span> <span class="n">x</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">x_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])))</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">concatenate</span><span class="p">((</span><span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span>
                                      <span class="nb">range</span><span class="p">(</span><span class="o">-</span><span class="n">y_inds</span><span class="p">,</span> <span class="mi">0</span><span class="p">)]),</span> <span class="n">y</span><span class="p">,</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="n">y</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span> <span class="o">*</span> <span class="n">i</span> <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">y_inds</span> <span class="o">+</span> <span class="mi">1</span><span class="p">)])))</span>
        <span class="c1"># The points on which we have data</span>
        <span class="n">points</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="c1"># The points corresponding to &quot;rings&quot; in cylindrical coordinates. Note we construct these</span>
        <span class="c1"># rings around the origin so we have to shift them to actually correspond to the center of</span>
        <span class="c1"># the nanowire</span>
        <span class="n">rvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">rmax</span><span class="p">,</span> <span class="n">rsamp</span><span class="p">)</span>
        <span class="n">thvec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">pi</span><span class="p">,</span> <span class="n">thsamp</span><span class="p">)</span>
        <span class="n">cyl_coords</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">)</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">2</span><span class="p">))</span>
        <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">r</span> <span class="ow">in</span> <span class="n">rvec</span><span class="p">:</span>
            <span class="n">xring</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">cos</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
            <span class="n">yring</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="n">sin</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
            <span class="n">cyl_coords</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xring</span>
            <span class="n">cyl_coords</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">start</span> <span class="o">+</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">),</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yring</span>
            <span class="n">start</span> <span class="o">+=</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">)</span>
        <span class="n">cyl_coords</span> <span class="o">+=</span> <span class="n">period</span> <span class="o">/</span> <span class="mf">2.0</span>
        <span class="c1"># For every z layer in the 3D matrix of our quantity</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">ext_vals</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">)))</span>
        <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">layer</span> <span class="ow">in</span> <span class="n">ext_vals</span><span class="p">:</span>
            <span class="n">interp_vals</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interpn</span><span class="p">(</span>
                <span class="n">points</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">cyl_coords</span><span class="p">,</span> <span class="n">method</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">)</span>
            <span class="n">rings</span> <span class="o">=</span> <span class="n">interp_vals</span><span class="o">.</span><span class="n">reshape</span><span class="p">((</span><span class="nb">len</span><span class="p">(</span><span class="n">rvec</span><span class="p">),</span> <span class="nb">len</span><span class="p">(</span><span class="n">thvec</span><span class="p">)))</span>
            <span class="n">avg</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">average</span><span class="p">(</span><span class="n">rings</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">avgs</span><span class="p">[</span><span class="n">i</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">avg</span>
            <span class="n">i</span> <span class="o">+=</span> <span class="mi">1</span>
        <span class="n">avgs</span> <span class="o">=</span> <span class="n">avgs</span><span class="p">[:,</span> <span class="p">::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1"># Save to avgs dict for this sim</span>
        <span class="n">key</span> <span class="o">=</span> <span class="n">quantity</span> <span class="o">+</span> <span class="s1">&#39;_angularAvg&#39;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">avgs</span>
        <span class="k">return</span> <span class="n">avgs</span></div>

<div class="viewcode-block" id="Simulation.transmissionData"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.transmissionData">[docs]</a>    <span class="k">def</span> <span class="nf">transmissionData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes reflection, transmission, and absorbance</span>

<span class="sd">        :param str port: Name of the location at which you would like to place the</span>
<span class="sd">                         transmission port (i.e where you would like to compute</span>
<span class="sd">                         transmission). This must correspond to one of the keys placed in</span>
<span class="sd">                         the fluxes dict located at self.data[&#39;fluxes&#39;]</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;fluxes&#39;</span><span class="p">]</span>
        <span class="c1"># sorted_layers is an OrderedDict, and thus has the popitem method</span>
        <span class="n">sorted_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="c1"># self.log.info(&#39;SORTED LAYERS: %s&#39;, str(sorted_layers))</span>
        <span class="n">first_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;FIRST LAYER: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_layer</span><span class="p">))</span>
        <span class="c1"># An ordered dict is actually just a list of tuples so we can access</span>
        <span class="c1"># the key directly like so</span>
        <span class="n">first_name</span> <span class="o">=</span> <span class="n">first_layer</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;FIRST LAYER NAME: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="nb">str</span><span class="p">(</span><span class="n">first_name</span><span class="p">))</span>
        <span class="c1"># p_inc = data[first_name][0]</span>
        <span class="c1"># p_ref = np.abs(data[first_name][1])</span>
        <span class="c1"># p_trans = data[last_name][0]</span>
        <span class="n">p_inc</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">p_ref</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">first_name</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">p_trans</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="n">port</span><span class="p">][</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">reflectance</span> <span class="o">=</span> <span class="n">p_ref</span> <span class="o">/</span> <span class="n">p_inc</span>
        <span class="n">transmission</span> <span class="o">=</span> <span class="n">p_trans</span> <span class="o">/</span> <span class="n">p_inc</span>
        <span class="n">absorbance</span> <span class="o">=</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">reflectance</span> <span class="o">-</span> <span class="n">transmission</span>
        <span class="n">tot</span> <span class="o">=</span> <span class="n">reflectance</span> <span class="o">+</span> <span class="n">transmission</span> <span class="o">+</span> <span class="n">absorbance</span>
        <span class="n">delta</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">tot</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Reflectance </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">reflectance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Transmission </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">transmission</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Absorbance </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">absorbance</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Total = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">tot</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">reflectance</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">assert</span><span class="p">(</span><span class="n">transmission</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
        <span class="c1"># assert(absorbance &gt;= 0)</span>
        <span class="c1"># assert(delta &lt; .00001)</span>
        <span class="k">if</span> <span class="s1">&#39;transmission_data&#39;</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">update</span><span class="p">({</span><span class="n">port</span><span class="p">:</span> <span class="p">(</span><span class="n">reflectance</span><span class="p">,</span>
                                                          <span class="n">transmission</span><span class="p">,</span>
                                                          <span class="n">absorbance</span><span class="p">)})</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="n">port</span><span class="p">:</span> <span class="p">(</span><span class="n">reflectance</span><span class="p">,</span>
                                                     <span class="n">transmission</span><span class="p">,</span>
                                                     <span class="n">absorbance</span><span class="p">)}</span>
        <span class="c1"># ftype = self.conf[&#39;General&#39;][&#39;save_as&#39;]</span>
        <span class="c1"># if ftype == &#39;npz&#39;:</span>
        <span class="c1">#     outpath = os.path.join(base, &#39;ref_trans_abs.dat&#39;)</span>
        <span class="c1">#     self.log.info(&#39;Writing transmission file&#39;)</span>
        <span class="c1">#     if os.path.isfile(outpath):</span>
        <span class="c1">#         with open(outpath, &#39;a&#39;) as out:</span>
        <span class="c1">#             out.write(&#39;%s,%f,%f,%f\n&#39; % (port, reflectance, transmission, absorbance))</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         with open(outpath, &#39;w&#39;) as out:</span>
        <span class="c1">#             out.write(&#39;# Port, Reflectance,Transmission,Absorbance\n&#39;)</span>
        <span class="c1">#             out.write(&#39;%s,%f,%f,%f\n&#39; % (port, reflectance, transmission, absorbance))</span>
        <span class="c1"># elif ftype == &#39;hdf5&#39;:</span>
        <span class="c1">#     group = &#39;/sim_{}&#39;.format(self.id)</span>
        <span class="c1">#     num_rows = len(list(self.conf[&#39;Layers&#39;].keys()))*2</span>
        <span class="c1">#     try:</span>
        <span class="c1">#         tb_path = group + &#39;/transmission_data&#39;</span>
        <span class="c1">#         table = self.hdf5.get_node(tb_path, classname=&#39;Table&#39;)</span>
        <span class="c1">#     except tb.NoSuchNodeError:</span>
        <span class="c1">#         table = self.hdf5.create_table(group, &#39;transmission_data&#39;,</span>
        <span class="c1">#                                        description=TransmissionData,</span>
        <span class="c1">#                                        expectedrows=num_rows)</span>
        <span class="c1">#     row = table.row</span>
        <span class="c1">#     row[&#39;layer&#39;] = port</span>
        <span class="c1">#     row[&#39;reflection&#39;] = reflectance</span>
        <span class="c1">#     row[&#39;transmission&#39;] = transmission</span>
        <span class="c1">#     row[&#39;absorption&#39;] = absorbance</span>
        <span class="c1">#     row.append()</span>
        <span class="c1">#     table.flush()</span>
        <span class="k">return</span> <span class="n">reflectance</span><span class="p">,</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">absorbance</span></div>

<div class="viewcode-block" id="Simulation.integrated_absorbtion"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.integrated_absorbtion">[docs]</a>    <span class="k">def</span> <span class="nf">integrated_absorbtion</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the absorption of a layer by using the volume integral of</span>
<span class="sd">        the product of the imaginary part of the relative permittivity and the</span>
<span class="sd">        norm squared of the E field</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">raise</span> <span class="ne">NotImplementedError</span><span class="p">(</span><span class="s1">&#39;There are some bugs in S4 and other reasons&#39;</span>
                                  <span class="s1">&#39; that this function doesnt work yet&#39;</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;integrated_absorption.dat&#39;</span><span class="p">)</span>
        <span class="n">inpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;energy_densities.dat&#39;</span><span class="p">)</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="c1"># TODO: Assuming incident amplitude and therefore incident power is</span>
        <span class="c1"># just 1 for now</span>
        <span class="n">fact</span> <span class="o">=</span> <span class="o">-.</span><span class="mi">5</span> <span class="o">*</span> <span class="n">freq</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">epsilon_0</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">inpath</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">inf</span><span class="p">:</span>
            <span class="n">lines</span> <span class="o">=</span> <span class="n">inf</span><span class="o">.</span><span class="n">readlines</span><span class="p">()</span>
            <span class="c1"># Remove header line</span>
            <span class="n">lines</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
            <span class="c1"># Dict where key is layer name and value is list of length 2 containing real and</span>
            <span class="c1"># imaginary parts of energy density integral</span>
            <span class="n">data</span> <span class="o">=</span> <span class="p">{</span><span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span><span class="mi">0</span><span class="p">]:</span> <span class="n">line</span><span class="o">.</span><span class="n">strip</span><span class="p">()</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)[</span>
                <span class="mi">1</span><span class="p">:]</span> <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">lines</span><span class="p">}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Energy densities: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">data</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Layer, Absorption</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">vals</span> <span class="ow">in</span> <span class="n">data</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">absorb</span> <span class="o">=</span> <span class="n">fact</span> <span class="o">*</span> <span class="nb">float</span><span class="p">(</span><span class="n">vals</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
                <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%s</span><span class="s1">,</span><span class="si">%s</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">layer</span><span class="p">,</span> <span class="n">absorb</span><span class="p">))</span></div>

    <span class="k">def</span> <span class="nf">_draw_layer_circle</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ldata</span><span class="p">,</span> <span class="n">shape_key</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Draws the circle within a layer&quot;&quot;&quot;</span>
        <span class="n">shape_data</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">][</span><span class="n">shape_key</span><span class="p">]</span>
        <span class="n">center</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s1">&#39;center&#39;</span><span class="p">]</span>
        <span class="n">radius</span> <span class="o">=</span> <span class="n">shape_data</span><span class="p">[</span><span class="s1">&#39;radius&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span><span class="p">:</span>
            <span class="n">circle</span> <span class="o">=</span> <span class="n">mpatches</span><span class="o">.</span><span class="n">Circle</span><span class="p">((</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">],</span> <span class="n">center</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]),</span> <span class="n">radius</span><span class="o">=</span><span class="n">radius</span><span class="p">,</span>
                                     <span class="n">fill</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_artist</span><span class="p">(</span><span class="n">circle</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xz&quot;</span><span class="p">,</span> <span class="s2">&quot;zx&quot;</span><span class="p">,</span> <span class="s2">&quot;yz&quot;</span><span class="p">,</span> <span class="s2">&quot;zy&quot;</span><span class="p">]:</span>
            <span class="n">plane_x</span> <span class="o">=</span> <span class="n">pval</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">dx</span>
            <span class="n">plane_to_center</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">abs</span><span class="p">(</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;x&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">plane_x</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;DIST: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">plane_to_center</span><span class="p">))</span>
            <span class="c1"># Only draw if the observation plane actually intersects with the</span>
            <span class="c1"># circle</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="n">plane_to_center</span> <span class="o">&gt;=</span> <span class="n">radius</span><span class="p">:</span>
                <span class="c1"># Check if the plane intersects with the center of the circle</span>
                <span class="k">if</span> <span class="n">plane_to_center</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">intersect_angle</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arccos</span><span class="p">(</span><span class="n">plane_to_center</span><span class="o">/</span><span class="n">radius</span><span class="p">)</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;ANGLE: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">intersect_angle</span><span class="p">))</span>
                    <span class="n">half_width</span> <span class="o">=</span> <span class="n">plane_to_center</span><span class="o">*</span><span class="n">np</span><span class="o">.</span><span class="n">tan</span><span class="p">(</span><span class="n">intersect_angle</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">half_width</span> <span class="o">=</span> <span class="n">radius</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;HALF WIDTH: </span><span class="si">{}</span><span class="s1">&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">half_width</span><span class="p">))</span>
                <span class="c1"># Vertical lines should span height of the layer</span>
                <span class="n">z</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">end</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">]</span>
                <span class="c1"># The upper edge</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">half_width</span><span class="p">]</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                     <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                <span class="c1"># Now the lower edge</span>
                <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="n">center</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">,</span> <span class="n">center</span><span class="p">[</span><span class="s1">&#39;y&#39;</span><span class="p">]</span> <span class="o">-</span> <span class="n">half_width</span><span class="p">]</span>
                <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                     <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax_hand</span>

    <span class="k">def</span> <span class="nf">_draw_layer_geometry</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ldata</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Given a dictionary with the data containing the geometry for a</span>
<span class="sd">        layer, draw the internal geometry of the layer for a given plane type</span>
<span class="sd">        and plane value&quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">shape</span><span class="p">,</span> <span class="n">data</span> <span class="ow">in</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;geometry&#39;</span><span class="p">]</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]</span> <span class="o">==</span> <span class="s1">&#39;circle&#39;</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_layer_circle</span><span class="p">(</span><span class="n">ldata</span><span class="p">,</span> <span class="n">shape</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span>
                                             <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;Drawing of shape </span><span class="si">{}</span><span class="s1"> not &#39;</span>
                                 <span class="s1">&#39;supported&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;type&#39;</span><span class="p">]))</span>
        <span class="k">return</span> <span class="n">ax</span>

<div class="viewcode-block" id="Simulation.draw_geometry_2d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.draw_geometry_2d">[docs]</a>    <span class="k">def</span> <span class="nf">draw_geometry_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;This function draws the layer boundaries and in-plane geometry on 2D</span>
<span class="sd">        heatmaps&quot;&quot;&quot;</span>
        <span class="c1"># Get the layers in order</span>
        <span class="n">ordered_layers</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="n">period</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="c1"># Loop through them</span>
        <span class="n">boundaries</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ldata</span> <span class="ow">in</span> <span class="n">ordered_layers</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="c1"># If x or y, draw bottom edge and text label now. Layer geometry</span>
            <span class="c1"># is handled in its own function</span>
            <span class="k">if</span> <span class="n">plane</span> <span class="ow">in</span> <span class="p">[</span><span class="s2">&quot;xz&quot;</span><span class="p">,</span> <span class="s2">&quot;zx&quot;</span><span class="p">,</span> <span class="s2">&quot;yz&quot;</span><span class="p">,</span> <span class="s2">&quot;zy&quot;</span><span class="p">]:</span>
                <span class="c1"># Get boundaries between layers and their starting and ending</span>
                <span class="c1"># indices</span>
                <span class="n">layer_t</span> <span class="o">=</span> <span class="n">ldata</span><span class="p">[</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">count</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">layer_t</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">layer_t</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">layer</span><span class="p">))</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">prev_tup</span> <span class="o">=</span> <span class="n">boundaries</span><span class="p">[</span><span class="n">count</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                    <span class="n">dist</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">+</span> <span class="n">layer_t</span>
                    <span class="n">start</span> <span class="o">=</span> <span class="n">prev_tup</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
                    <span class="n">end</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dist</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span> <span class="o">+</span> <span class="mi">1</span>
                    <span class="n">boundaries</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">dist</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">))</span>
                <span class="k">if</span> <span class="n">layer_t</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">x</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">]</span>
                    <span class="n">y</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span>
                         <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">-</span> <span class="n">start</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">]</span>
                    <span class="n">label_y</span> <span class="o">=</span> <span class="n">y</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mf">0.25</span>
                    <span class="n">label_x</span> <span class="o">=</span> <span class="n">x</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="o">.</span><span class="mi">01</span>
                    <span class="n">plt</span><span class="o">.</span><span class="n">text</span><span class="p">(</span><span class="n">label_x</span><span class="p">,</span> <span class="n">label_y</span><span class="p">,</span> <span class="n">layer</span><span class="p">,</span> <span class="n">ha</span><span class="o">=</span><span class="s1">&#39;right&#39;</span><span class="p">,</span>
                             <span class="n">family</span><span class="o">=</span><span class="s1">&#39;sans-serif&#39;</span><span class="p">,</span> <span class="n">size</span><span class="o">=</span><span class="mi">16</span><span class="p">,</span> <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                    <span class="n">line</span> <span class="o">=</span> <span class="n">mlines</span><span class="o">.</span><span class="n">Line2D</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">linestyle</span><span class="o">=</span><span class="s1">&#39;solid&#39;</span><span class="p">,</span> <span class="n">linewidth</span><span class="o">=</span><span class="mf">2.0</span><span class="p">,</span>
                                         <span class="n">color</span><span class="o">=</span><span class="s1">&#39;grey&#39;</span><span class="p">)</span>
                    <span class="n">ax_hand</span><span class="o">.</span><span class="n">add_line</span><span class="p">(</span><span class="n">line</span><span class="p">)</span>
                    <span class="n">count</span> <span class="o">+=</span> <span class="mi">1</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1"># If look at a fixed z pval, the start and end values are</span>
                <span class="c1"># nonsensical but we must pass a value in</span>
                <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span>
            <span class="c1"># If we have some internal geometry for this layer, draw it</span>
            <span class="k">if</span> <span class="s1">&#39;geometry&#39;</span> <span class="ow">in</span> <span class="n">ldata</span><span class="p">:</span>
                <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_draw_layer_geometry</span><span class="p">(</span><span class="n">ldata</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax_hand</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ax</span></div>

<div class="viewcode-block" id="Simulation.heatmap2d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.heatmap2d">[docs]</a>    <span class="k">def</span> <span class="nf">heatmap2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">save_path</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">show</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">colorsMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A general utility method for plotting a 2D heat map&quot;&quot;&quot;</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colorsMap</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">fixed</span><span class="p">:</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
                <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="mf">5.0</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="mf">100.0</span><span class="p">))</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span>
                <span class="n">vmin</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amin</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="n">np</span><span class="o">.</span><span class="n">amax</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
            <span class="c1"># cNorm = matplotlib.colors.LogNorm(vmin=np.amin(cs)+.001, vmax=np.amax(cs))</span>
            <span class="c1"># cNorm = matplotlib.colors.LogNorm(vmin=1e13, vmax=np.amax(cs))</span>
        <span class="n">scalarMap</span> <span class="o">=</span> <span class="n">cmx</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">10</span><span class="p">,</span> <span class="mi">8</span><span class="p">))</span>
        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">imshow</span><span class="p">(</span><span class="n">cs</span><span class="p">,</span><span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">,</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span><span class="n">extent</span><span class="o">=</span><span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">x</span><span class="o">.</span><span class="n">max</span><span class="p">(),</span><span class="n">y</span><span class="o">.</span><span class="n">min</span><span class="p">(),</span><span class="n">y</span><span class="o">.</span><span class="n">max</span><span class="p">()],</span><span class="n">aspect</span><span class="o">=</span><span class="s1">&#39;auto&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">grid</span><span class="p">(</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">scalarMap</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="c1"># div = make_axes_locatable(ax)</span>
        <span class="c1"># zoom_ax = div.append_axes(&quot;right&quot;,size=&#39;100%&#39;, pad=.5)</span>
        <span class="c1"># zoom_ax.imshow(cs[75:100,:], extent=[x.min(), x.max(), .8, 1.4])</span>
        <span class="c1"># zoom_ax.grid(False)</span>
        <span class="c1"># cax = div.append_axes(&quot;right&quot;,size=&quot;100%&quot;,pad=.05)</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarMap</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">draw</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Beginning geometry drawing routines ...&#39;</span><span class="p">)</span>
            <span class="n">ax</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">draw_geometry_2d</span><span class="p">(</span><span class="n">ptype</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">ax</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">save_path</span><span class="p">:</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">save_path</span><span class="p">,</span> <span class="n">bbox_inches</span><span class="o">=</span><span class="s1">&#39;tight&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.plane_2d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.plane_2d">[docs]</a>    <span class="k">def</span> <span class="nf">plane_2d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots a heatmap of a fixed 2D plane&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting plane&#39;</span><span class="p">)</span>
        <span class="n">pval</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">pval</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="c1"># Get the scalar values</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">wvlgth</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1E9</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Frequency = </span><span class="si">{:.4E}</span><span class="s1"> Hz, Wavelength = </span><span class="si">{:.2f}</span><span class="s1"> nm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">wvlgth</span><span class="p">)</span>
        <span class="c1"># Get the plane we wish to plot</span>
        <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;DATA SHAPE: </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="nb">str</span><span class="p">(</span><span class="n">cs</span><span class="o">.</span><span class="n">shape</span><span class="p">))</span>
        <span class="n">show</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
        <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zy&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_yz_pval</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">quantity</span><span class="p">,</span>
                                                               <span class="nb">str</span><span class="p">(</span><span class="n">pval</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zx&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_xz_pval</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">quantity</span><span class="p">,</span>
                                                               <span class="nb">str</span><span class="p">(</span><span class="n">pval</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yx&#39;</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span>
                                 <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_plane_2d_xy_pval</span><span class="si">%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">quantity</span><span class="p">,</span>
                                                               <span class="nb">str</span><span class="p">(</span><span class="n">pval</span><span class="p">)))</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                           <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.scatter3d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.scatter3d">[docs]</a>    <span class="k">def</span> <span class="nf">scatter3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">colorsMap</span><span class="o">=</span><span class="s1">&#39;jet&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;A general utility method for scatter plots in 3D&quot;&quot;&quot;</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="n">colorsMap</span><span class="p">)</span>
        <span class="n">cNorm</span> <span class="o">=</span> <span class="n">matplotlib</span><span class="o">.</span><span class="n">colors</span><span class="o">.</span><span class="n">Normalize</span><span class="p">(</span><span class="n">vmin</span><span class="o">=</span><span class="nb">min</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">vmax</span><span class="o">=</span><span class="nb">max</span><span class="p">(</span><span class="n">cs</span><span class="p">))</span>
        <span class="n">scalarMap</span> <span class="o">=</span> <span class="n">cmx</span><span class="o">.</span><span class="n">ScalarMappable</span><span class="p">(</span><span class="n">norm</span><span class="o">=</span><span class="n">cNorm</span><span class="p">,</span> <span class="n">cmap</span><span class="o">=</span><span class="n">cm</span><span class="p">)</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>

        <span class="n">ax</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">add_subplot</span><span class="p">(</span><span class="mi">111</span><span class="p">,</span> <span class="n">projection</span><span class="o">=</span><span class="s1">&#39;3d&#39;</span><span class="p">)</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">scatter</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">c</span><span class="o">=</span><span class="n">scalarMap</span><span class="o">.</span><span class="n">to_rgba</span><span class="p">(</span><span class="n">cs</span><span class="p">),</span> <span class="n">edgecolor</span><span class="o">=</span><span class="s1">&#39;none&#39;</span><span class="p">)</span>
        <span class="n">scalarMap</span><span class="o">.</span><span class="n">set_array</span><span class="p">(</span><span class="n">cs</span><span class="p">)</span>
        <span class="n">cb</span> <span class="o">=</span> <span class="n">fig</span><span class="o">.</span><span class="n">colorbar</span><span class="p">(</span><span class="n">scalarMap</span><span class="p">)</span>
        <span class="n">cb</span><span class="o">.</span><span class="n">set_label</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">3</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">ax</span><span class="o">.</span><span class="n">set_zlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="n">fig</span><span class="o">.</span><span class="n">suptitle</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">]))</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">ptype</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.full_3d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.full_3d">[docs]</a>    <span class="k">def</span> <span class="nf">full_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Generates a full 3D plot of a specified scalar quantity&quot;&quot;&quot;</span>
        <span class="c1"># The data just tells you what integer grid point you are on. Not what actual x,y coordinate you</span>
        <span class="c1"># are at</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="n">points</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="c1"># Get the scalar</span>
        <span class="n">scalar</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;X [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="c1"># Now plot!</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter3d</span><span class="p">(</span><span class="n">points</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">points</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">points</span><span class="p">[</span>
                       <span class="p">:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">scalar</span><span class="o">.</span><span class="n">flatten</span><span class="p">(),</span> <span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;full_3d&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.planes_3d"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.planes_3d">[docs]</a>    <span class="k">def</span> <span class="nf">planes_3d</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">xplane</span><span class="p">,</span> <span class="n">yplane</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots some scalar quantity in 3D but only along specified x-z and y-z planes&quot;&quot;&quot;</span>
        <span class="n">xplane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">xplane</span><span class="p">)</span>
        <span class="n">yplane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">yplane</span><span class="p">)</span>
        <span class="c1"># Get the scalar values</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span><span class="p">)</span>
        <span class="c1"># Get the data on the plane with a fixed x value. These means we&#39;ll</span>
        <span class="c1"># have changing (y, z) points</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="s1">&#39;yz&#39;</span><span class="p">,</span> <span class="n">xplane</span><span class="p">)</span>
        <span class="c1"># z first cuz we want y to be changing before z to correspond with the</span>
        <span class="c1"># way numpy flattens arrays. Note this means y points will be in the</span>
        <span class="c1"># 2nd column</span>
        <span class="n">xplanepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">y</span><span class="p">)))</span>
        <span class="n">xdata</span> <span class="o">=</span> <span class="n">xdata</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">xplanexval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">xplane</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">xdata</span><span class="p">))))</span>
        <span class="n">xplanedata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">xplanepoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanexval</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanepoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">xplanepoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">xplanedata</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">xdata</span>
        <span class="c1"># Same procedure for fixed y plane</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="s1">&#39;xz&#39;</span><span class="p">,</span> <span class="n">yplane</span><span class="p">)</span>
        <span class="n">yplanepoints</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">product</span><span class="p">(</span><span class="n">z</span><span class="p">,</span> <span class="n">x</span><span class="p">)))</span>
        <span class="n">ydata</span> <span class="o">=</span> <span class="n">ydata</span><span class="o">.</span><span class="n">flatten</span><span class="p">()</span>
        <span class="n">yplaneyval</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="nb">list</span><span class="p">(</span><span class="n">itertools</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">y</span><span class="p">[</span><span class="n">yplane</span><span class="p">],</span> <span class="nb">len</span><span class="p">(</span><span class="n">ydata</span><span class="p">))))</span>
        <span class="n">yplanedata</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="n">yplanepoints</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="mi">4</span><span class="p">))</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplanepoints</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplaneyval</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="n">yplanepoints</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">]</span>
        <span class="n">yplanedata</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="n">ydata</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;X [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="c1"># Now stack them vertically and plot!</span>
        <span class="n">all_data</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">vstack</span><span class="p">((</span><span class="n">xplanedata</span><span class="p">,</span> <span class="n">yplanedata</span><span class="p">))</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scatter3d</span><span class="p">(</span><span class="n">all_data</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">],</span> <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">],</span> <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">2</span><span class="p">],</span>
                       <span class="n">all_data</span><span class="p">[:,</span> <span class="mi">3</span><span class="p">],</span> <span class="n">labels</span><span class="p">,</span> <span class="s1">&#39;planes_3d&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.line_plot"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.line_plot">[docs]</a>    <span class="k">def</span> <span class="nf">line_plot</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">labels</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Make a simple line plot&quot;&quot;&quot;</span>
        <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">labels</span><span class="p">[</span><span class="mi">2</span><span class="p">])</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">labels</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">+</span> <span class="s1">&#39;_&#39;</span> <span class="o">+</span> <span class="n">ptype</span> <span class="o">+</span> <span class="s1">&#39;.pdf&#39;</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;sim_dir&#39;</span><span class="p">],</span> <span class="n">name</span><span class="p">)</span>
            <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="Simulation.fixed_line"><a class="viewcode-back" href="../../utils.html#utils.simulation.Simulation.fixed_line">[docs]</a>    <span class="k">def</span> <span class="nf">fixed_line</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot a scalar quantity on a line along a the z direction at some pair of</span>
<span class="sd">        coordinates in the plane perpendicular to that direction&quot;&quot;&quot;</span>
        <span class="n">coord1</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord1</span><span class="p">)</span>
        <span class="n">coord2</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">coord2</span><span class="p">)</span>
        <span class="c1"># Get the scalar values</span>
        <span class="c1"># Filter out any undesired data that isn&#39;t on the planes</span>
        <span class="n">data</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_line</span><span class="p">(</span><span class="n">quantity</span><span class="p">,</span> <span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">x_samples</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">period</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">height</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">z_samples</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;x&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">x</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;y&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">y</span>
        <span class="k">elif</span> <span class="n">direction</span> <span class="o">==</span> <span class="s1">&#39;z&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="n">pos_data</span> <span class="o">=</span> <span class="n">z</span>
        <span class="n">freq</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">wvlgth</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span><span class="p">)</span> <span class="o">*</span> <span class="mf">1E9</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Frequency = </span><span class="si">{:.4E}</span><span class="s1"> Hz, Wavelength = </span><span class="si">{:.2f}</span><span class="s1"> nm&#39;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span>
            <span class="n">freq</span><span class="p">,</span> <span class="n">wvlgth</span><span class="p">)</span>
        <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;Z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
        <span class="n">ptype</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="si">%s</span><span class="s2">_line_plot_</span><span class="si">%i</span><span class="s2">_</span><span class="si">%i</span><span class="s2">&quot;</span> <span class="o">%</span> <span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="n">coord1</span><span class="p">,</span> <span class="n">coord2</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">line_plot</span><span class="p">(</span><span class="n">pos_data</span><span class="p">,</span> <span class="n">data</span><span class="p">,</span> <span class="n">ptype</span><span class="p">,</span> <span class="n">labels</span><span class="p">)</span></div></div>

<div class="viewcode-block" id="SimulationGroup"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup">[docs]</a><span class="k">class</span> <span class="nc">SimulationGroup</span><span class="p">:</span>

    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    A group of simulations. Takes a list of Simulation objects as an argument.</span>
<span class="sd">    This class is not responsible for grouping Simulation objects by some</span>
<span class="sd">    criteria, it just expects a list of already grouped Simulation objects.</span>

<span class="sd">    Provides methods for calculating things on a group of simulations. The</span>
<span class="sd">    results of these methods might not be sensible for some groupings. For</span>
<span class="sd">    example, calculating the convergence of a group that is group against</span>
<span class="sd">    frequency doesn&#39;t make any sense. Similiarly, calculating Jsc of a group</span>
<span class="sd">    that is grouped against number of basis terms also doesn&#39;t make sense.</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sims</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span> <span class="o">=</span> <span class="n">sims</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span> <span class="o">=</span> <span class="n">logging</span><span class="o">.</span><span class="n">getLogger</span><span class="p">(</span><span class="s1">&#39;postprocess&#39;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">sims</span><span class="p">)</span>


<div class="viewcode-block" id="SimulationGroup.get_plane"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.get_plane">[docs]</a>    <span class="k">def</span> <span class="nf">get_plane</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">scalar</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Gets data along a 2D plane/slice through the 3D data array for a given</span>
<span class="sd">        quantity</span>

<span class="sd">        :param str plane: Any of &#39;xy&#39;, &#39;yz&#39;, or &#39;xz&#39;. Determines the plane</span>
<span class="sd">        along which the slice is taken</span>
<span class="sd">        :param int pval: The index along the final unspecified direction. If</span>
<span class="sd">        plane=&#39;xy&#39; then index would index along the z direction.</span>
<span class="sd">        :param str quantity: The quantity whose data array you wish to take a</span>
<span class="sd">        line cut through</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zy&#39;</span><span class="p">:</span>
            <span class="c1"># z along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="n">pval</span><span class="p">,</span> <span class="p">:]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zx&#39;</span><span class="p">:</span>
            <span class="c1"># x along columns, z along rows</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[:,</span> <span class="p">:,</span> <span class="n">pval</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yx&#39;</span><span class="p">:</span>
            <span class="c1"># x along rows, y along columns</span>
            <span class="k">return</span> <span class="n">scalar</span><span class="p">[</span><span class="n">pval</span><span class="p">,</span> <span class="p">:,</span> <span class="p">:]</span></div>

<div class="viewcode-block" id="SimulationGroup.diff_sq"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.diff_sq">[docs]</a>    <span class="k">def</span> <span class="nf">diff_sq</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the magnitude of the difference vector squared between two vector fields at each</span>
<span class="sd">        point in space&quot;&quot;&quot;</span>
        <span class="c1"># Calculate the magnitude of the difference vector SQUARED at each point in space</span>
        <span class="c1"># This is mag(vec(x) - vec(y))^2 at each point in space. This should be a 1D array</span>
        <span class="c1"># with # of elements = # sampling points</span>
        <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">([</span><span class="n">np</span><span class="o">.</span><span class="n">absolute</span><span class="p">(</span><span class="n">v1</span> <span class="o">-</span> <span class="n">v2</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span> <span class="k">for</span> <span class="n">v1</span><span class="p">,</span> <span class="n">v2</span> <span class="ow">in</span> <span class="nb">zip</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)])</span>
        <span class="k">return</span> <span class="n">mag_diff_vec</span></div>

<div class="viewcode-block" id="SimulationGroup.get_slice"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.get_slice">[docs]</a>    <span class="k">def</span> <span class="nf">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns indices for data that strip out air and substrate regions&quot;&quot;&quot;</span>
        <span class="c1"># TODO: This function is definitely not general. We need to get a list</span>
        <span class="c1"># of layers to exclude from the user. For now, just assume we want to</span>
        <span class="c1"># exclude the top and bottom regions</span>
        <span class="c1"># sorted_layers is an OrderedDict, and thus has the popitem method</span>
        <span class="n">sorted_layers</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="o">.</span><span class="n">sorted_dict</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Layers&#39;</span><span class="p">])</span>
        <span class="n">first_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">(</span><span class="n">last</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="n">last_layer</span> <span class="o">=</span> <span class="n">sorted_layers</span><span class="o">.</span><span class="n">popitem</span><span class="p">()</span>
        <span class="c1"># We can get the starting and ending planes from their heights</span>
        <span class="n">start_plane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">first_layer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                          <span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">))</span>
        <span class="n">end_plane</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="nb">round</span><span class="p">(</span><span class="n">last_layer</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                        <span class="s1">&#39;thickness&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span> <span class="o">/</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">start_plane</span><span class="p">,</span> <span class="n">end_plane</span></div>

<div class="viewcode-block" id="SimulationGroup.get_comp_vec"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.get_comp_vec">[docs]</a>    <span class="k">def</span> <span class="nf">get_comp_vec</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the comparison vector&quot;&quot;&quot;</span>
        <span class="c1"># Compare all other sims to our best estimate, which is sim with highest number of</span>
        <span class="c1"># basis terms (last in list cuz sorting)</span>

        <span class="c1"># Get the proper file extension depending on the field.</span>
        <span class="n">norm</span> <span class="o">=</span> <span class="s1">&#39;norm&#39;</span><span class="o">+</span><span class="n">field</span>
        <span class="c1"># Get the comparison vector</span>
        <span class="n">vecs</span> <span class="o">=</span> <span class="p">[</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="n">field</span><span class="o">+</span><span class="n">comp</span><span class="p">][</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span> <span class="k">for</span> <span class="n">comp</span> <span class="ow">in</span> <span class="p">(</span><span class="s1">&#39;x&#39;</span><span class="p">,</span> <span class="s1">&#39;y&#39;</span><span class="p">,</span> <span class="s1">&#39;z&#39;</span><span class="p">)]</span>
        <span class="n">normvec</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="s1">&#39;normE&#39;</span><span class="p">)</span>
        <span class="n">normvec</span> <span class="o">=</span> <span class="n">normvec</span><span class="p">[</span><span class="n">start</span><span class="p">:</span><span class="n">end</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span>
        <span class="k">return</span> <span class="n">vecs</span><span class="p">,</span> <span class="n">normvec</span></div>

<div class="viewcode-block" id="SimulationGroup.local_error"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.local_error">[docs]</a>    <span class="k">def</span> <span class="nf">local_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the average of the local error between the vector fields of two simulations at</span>
<span class="sd">        each point in space&quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Running the local error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;localerror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing local error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="c1"># Set the reference sim</span>
            <span class="n">ref_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Get the comparison vector</span>
            <span class="n">vecs1</span><span class="p">,</span> <span class="n">normvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="c1"># For all other sims in the groups, compare to best estimate</span>
            <span class="c1"># and write to error file</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sim2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vecs2</span><span class="p">,</span> <span class="n">normvec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">sim2</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing local error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span> <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                              <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                <span class="c1"># in space</span>
                <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vecs1</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">)</span>
                <span class="c1"># Normalize the magnitude squared of the difference vector by the magnitude squared of</span>
                <span class="c1"># the local electric field of the comparison simulation at</span>
                <span class="c1"># each point in space</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="n">norm_mag_diff</span> <span class="o">=</span> <span class="n">mag_diff_vec</span> <span class="o">/</span> <span class="n">normvec</span>
                <span class="c1"># Compute the average of the normalized magnitude of all</span>
                <span class="c1"># the difference vectors</span>
                <span class="n">avg_diffvec_mag</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">norm_mag_diff</span><span class="p">)</span> <span class="o">/</span> <span class="n">norm_mag_diff</span><span class="o">.</span><span class="n">size</span>
                <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span>
                              <span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">avg_diffvec_mag</span><span class="p">))</span>
                <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
            <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimulationGroup.global_error"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.global_error">[docs]</a>    <span class="k">def</span> <span class="nf">global_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the global error between the vector fields of two simulations. This is the sum</span>
<span class="sd">        of the magnitude squared of the difference vectors divided by the sum of the magnitude</span>
<span class="sd">        squared of the comparison efield vector over the desired section of the simulation cell&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Running the global error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="c1"># base = self.sims[0].conf[&#39;General&#39;][&#39;base_dir&#39;]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;globalerror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing global error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="c1"># Set reference sim</span>
            <span class="n">ref_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
            <span class="c1"># Get the comparison vector</span>
            <span class="n">vecs1</span><span class="p">,</span> <span class="n">normvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
            <span class="c1"># For all other sims in the groups, compare to best estimate</span>
            <span class="c1"># and write to error file</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span> <span class="o">-</span> <span class="mi">1</span><span class="p">):</span>
                <span class="n">sim2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="n">vecs2</span><span class="p">,</span> <span class="n">normvec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">sim2</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing global error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span> <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                              <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                <span class="c1"># in space</span>
                <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vecs1</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">)</span>
                <span class="c1"># Check for equal lengths between norm array and diff mag</span>
                <span class="c1"># array</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span> <span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="c1"># Error as a percentage should be the square root of the ratio of sum of mag diff vec</span>
                <span class="c1"># squared to mag efield squared</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normvec</span><span class="p">))</span>
                <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">error</span><span class="p">))</span>
                <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
            <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimulationGroup.adjacent_error"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.adjacent_error">[docs]</a>    <span class="k">def</span> <span class="nf">adjacent_error</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">exclude</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes the global error between the vector fields of two simulations. This is the sum</span>
<span class="sd">        of the magnitude squared of the difference vectors divided by the sum of the magnitude</span>
<span class="sd">        squared of the comparison efield vector over the desired section of the simulation cell.</span>
<span class="sd">        This computes error between adjacent sims in a sweep through basis terms.&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Running the adjacent error computation for quantity </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">field</span><span class="p">)</span>
        <span class="c1"># If we need to exclude calculate the indices</span>
        <span class="k">if</span> <span class="n">exclude</span><span class="p">:</span>
            <span class="n">start</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_slice</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">start</span> <span class="o">=</span> <span class="mi">0</span>
            <span class="n">end</span> <span class="o">=</span> <span class="kc">None</span>
            <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="n">errpath</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;adjacenterror_</span><span class="si">%s%s</span><span class="s1">.dat&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">field</span><span class="p">,</span> <span class="n">excluded</span><span class="p">))</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">errpath</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">errfile</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing adjacent error for sweep </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
            <span class="c1"># For all other sims in the groups, compare to best estimate</span>
            <span class="c1"># and write to error file</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">):</span>
                <span class="c1"># Set reference sim</span>
                <span class="n">ref_sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
                <span class="c1"># Get the comparison vector</span>
                <span class="n">vecs1</span><span class="p">,</span> <span class="n">normvec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">ref_sim</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="n">sim2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="n">i</span> <span class="o">-</span> <span class="mi">1</span><span class="p">]</span>
                <span class="n">vecs2</span><span class="p">,</span> <span class="n">normvec2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_comp_vec</span><span class="p">(</span><span class="n">sim2</span><span class="p">,</span> <span class="n">field</span><span class="p">,</span> <span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s2">&quot;Computing adjacent error between numbasis </span><span class="si">%i</span><span class="s2"> and numbasis </span><span class="si">%i</span><span class="s2">&quot;</span><span class="p">,</span>
                              <span class="n">ref_sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span> <span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span>
                              <span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">])</span>
                <span class="c1"># Get the array containing the magnitude of the difference vector at each point</span>
                <span class="c1"># in space</span>
                <span class="n">mag_diff_vec</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">diff_sq</span><span class="p">(</span><span class="n">vecs1</span><span class="p">,</span> <span class="n">vecs2</span><span class="p">)</span>
                <span class="c1"># Check for equal lengths between norm array and diff mag</span>
                <span class="c1"># array</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">!=</span> <span class="nb">len</span><span class="p">(</span><span class="n">normvec</span><span class="p">):</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s2">&quot;The normalization vector has an incorrect number of elements!!!&quot;</span><span class="p">)</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span>
                <span class="c1"># Error as a percentage should be thkkk square root of the ratio of sum of mag diff vec</span>
                <span class="c1"># squared to mag efield squared</span>
                <span class="n">error</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">mag_diff_vec</span><span class="p">)</span> <span class="o">/</span> <span class="n">np</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="n">normvec</span><span class="p">))</span>
                <span class="c1"># self.log.info(str(error))</span>
                <span class="n">errfile</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%i</span><span class="s1">,</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">sim2</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;numbasis&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">],</span> <span class="n">error</span><span class="p">))</span>
                <span class="n">sim2</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
                <span class="n">ref_sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span></div>

<div class="viewcode-block" id="SimulationGroup.scalar_reduce"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.scalar_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">scalar_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">avg</span><span class="o">=</span><span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Combine a scalar quantity across all simulations in each group. If</span>
<span class="sd">        avg=False then a direct sum is computed, otherwise an average is</span>
<span class="sd">        computed</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Performing scalar reduction for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="s1">&#39;QUANTITY: </span><span class="si">%s</span><span class="s1">&#39;</span><span class="o">%</span><span class="n">quantity</span><span class="p">)</span>
        <span class="n">group_comb</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">group_comb</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
        <span class="c1"># This approach is more memory efficient then building a 2D array</span>
        <span class="c1"># of all the data from each group and summing along an axis</span>
        <span class="k">for</span> <span class="n">sim</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">sim</span><span class="o">.</span><span class="n">id</span><span class="p">)</span>
            <span class="n">quant</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">get_scalar_quantity</span><span class="p">(</span><span class="n">quantity</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="n">quant</span><span class="o">.</span><span class="n">dtype</span><span class="p">)</span>
            <span class="n">group_comb</span> <span class="o">+=</span> <span class="n">quant</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">avg</span><span class="p">:</span>
            <span class="n">group_comb</span> <span class="o">=</span> <span class="n">group_comb</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_avg_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group_comb</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;FIX HDF5 SCALAR REDUCE SAVING&#39;</span><span class="p">)</span>
            <span class="n">np</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">group_comb</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Invalid file type in config&#39;</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimulationGroup.fractional_absorbtion"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.fractional_absorbtion">[docs]</a>    <span class="k">def</span> <span class="nf">fractional_absorbtion</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Computes the fraction of the incident spectrum that is absorbed by</span>
<span class="sd">        the device. This is a unitless number, and its interpretation somewhat</span>
<span class="sd">        depends on the units you express the incident spectrum in. If you</span>
<span class="sd">        expressed your incident spectrum in photon number, this can be</span>
<span class="sd">        interpreted as the fraction of incident photons that were absorbed. If</span>
<span class="sd">        you expressed your incident spectrum in terms of power per unit area,</span>
<span class="sd">        then this can be interpreted as the fraction of incident power per unit</span>
<span class="sd">        area that gets absorbed. In summary, its the fraction of whatever you</span>
<span class="sd">        put in that is being absorbed by the device.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing fractional absorbtion for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
        <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="c1"># Assuming the sims have been grouped by frequency, sum over all of</span>
        <span class="c1"># them</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">):</span>
            <span class="c1"># Unpack data for the port we passed in as an argument</span>
            <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">][</span><span class="n">port</span><span class="p">]</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
            <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mf">1e9</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
            <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth</span>
            <span class="c1"># Get solar power from chosen spectrum</span>
            <span class="c1"># Get p at wvlength by interpolation</span>
            <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
            <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span> <span class="o">*</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
        <span class="c1"># Use Trapezoid rule to perform the integration. Note all the</span>
        <span class="c1"># necessary factors of the wavelength have already been included</span>
        <span class="c1"># above</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="c1">#Jsc = intg.simps(Jsc_vals,x=wvlgths,even=&#39;avg&#39;)</span>
        <span class="n">integrated_absorbtion</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span>
        <span class="c1"># factor of 1/10 to convert A*m^-2 to mA*cm^-2</span>
        <span class="c1">#wv_fact = c.e/(c.c*c.h*10)</span>
        <span class="c1">#wv_fact = .1</span>
        <span class="c1">#Jsc = (Jsc*wv_fact)/power</span>
        <span class="n">frac_absorb</span> <span class="o">=</span> <span class="n">integrated_absorbtion</span> <span class="o">/</span> <span class="n">power</span>
        <span class="n">outf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;fractional_absorbtion.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">frac_absorb</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Fractional Absorbtion = </span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">frac_absorb</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">frac_absorb</span></div>

<div class="viewcode-block" id="SimulationGroup.Jsc"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.Jsc">[docs]</a>    <span class="k">def</span> <span class="nf">Jsc</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes photocurrent density. This is just the integrated</span>
<span class="sd">        absorption scaled by a unitful factor. Assuming perfect carrier</span>
<span class="sd">        collection, meaning every incident photon gets converted to 1 collected</span>
<span class="sd">        electron, this factor is q/(hbar*c) which converts to a current per</span>
<span class="sd">        unit area&quot;&quot;&quot;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing photocurrent density for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="c1"># Assuming the sims have been grouped by frequency, sum over all of</span>
        <span class="c1"># them</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">):</span>
            <span class="c1"># Unpack data for the port we passed in as an argument</span>
            <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">][</span><span class="n">port</span><span class="p">]</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
            <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mf">1e9</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
            <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth</span>
            <span class="c1"># Get solar power from chosen spectrum</span>
            <span class="n">path</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
            <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
            <span class="c1"># Get p at wvlength by interpolation</span>
            <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                        <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
            <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
            <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="c1"># This is our integrand</span>
            <span class="n">vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span> <span class="o">*</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">sim</span><span class="o">.</span><span class="n">clear_data</span><span class="p">()</span>
        <span class="c1"># Use Trapezoid rule to perform the integration. Note all the</span>
        <span class="c1"># necessary factors of the wavelength have already been included</span>
        <span class="c1"># above</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">vals</span> <span class="o">=</span> <span class="n">vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">integrated_absorbtion</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span>
        <span class="c1"># factor of 1/10 to convert A*m^-2 to mA*cm^-2</span>
        <span class="n">wv_fact</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">e</span> <span class="o">/</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">*</span> <span class="n">c</span><span class="o">.</span><span class="n">h</span> <span class="o">*</span> <span class="mi">10</span><span class="p">)</span>
        <span class="n">Jsc</span> <span class="o">=</span> <span class="n">wv_fact</span> <span class="o">*</span> <span class="n">integrated_absorbtion</span>
        <span class="n">outf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;jsc.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Jsc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Jsc = </span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Jsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Jsc</span></div>

<div class="viewcode-block" id="SimulationGroup.Jsc_integrated"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.Jsc_integrated">[docs]</a>    <span class="k">def</span> <span class="nf">Jsc_integrated</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Compute te photocurrent density by performing a volume integral of the</span>
<span class="sd">        generation rate</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_genRate.npy&#39;</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing integrated Jsc for group at </span><span class="si">%s</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">genRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">FileNotFoundError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">scalar_reduce</span><span class="p">(</span><span class="s1">&#39;genRate&#39;</span><span class="p">)</span>
            <span class="n">genRate</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
        <span class="c1"># Gen rate in cm^-3. Gotta convert lengths here from um to cm</span>
        <span class="n">z_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">height</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">z_samples</span><span class="p">)</span>
        <span class="n">x_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">period</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">x_samples</span><span class="p">)</span>
        <span class="n">y_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">period</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">y_samples</span><span class="p">)</span>
        <span class="n">z_integral</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">genRate</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">z_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">x_integral</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">z_integral</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">x_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">y_integral</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">x_integral</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">y_vals</span><span class="p">,</span> <span class="n">axis</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="c1"># Convert period to cm and current to mA</span>
        <span class="n">Jsc</span> <span class="o">=</span> <span class="mi">1000</span><span class="o">*</span><span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">e</span><span class="o">/</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">period</span><span class="o">*</span><span class="mf">1e-4</span><span class="p">)</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span><span class="o">*</span><span class="n">y_integral</span>
        <span class="n">outf</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;jsc_integrated.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">outf</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">out</span><span class="p">:</span>
            <span class="n">out</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="se">\n</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">Jsc</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Jsc_integrated = </span><span class="si">%f</span><span class="s1">&#39;</span><span class="p">,</span> <span class="n">Jsc</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Jsc</span></div>

<div class="viewcode-block" id="SimulationGroup.weighted_transmissionData"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.weighted_transmissionData">[docs]</a>    <span class="k">def</span> <span class="nf">weighted_transmissionData</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Computes spectrally weighted absorption,transmission, and reflection&quot;&quot;&quot;</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Computing spectrally weighted transmission data for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="n">abs_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">ref_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">trans_vals</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="c1"># Get solar power from chosen spectrum</span>
        <span class="n">path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;input_power_wv&#39;</span><span class="p">]</span>
        <span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">loadtxt</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="n">usecols</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">unpack</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">delimiter</span><span class="o">=</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
        <span class="c1"># Get interpolating function for power</span>
        <span class="n">p_wv</span> <span class="o">=</span> <span class="n">interpolate</span><span class="o">.</span><span class="n">interp1d</span><span class="p">(</span><span class="n">wv_vec</span><span class="p">,</span> <span class="n">p_vec</span><span class="p">,</span> <span class="n">kind</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">,</span>
                                    <span class="n">bounds_error</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fill_value</span><span class="o">=</span><span class="s1">&#39;extrapolate&#39;</span><span class="p">)</span>
        <span class="c1"># Assuming the leaves contain frequency values, sum over all of them</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">):</span>
            <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">][</span><span class="n">port</span><span class="p">]</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">wvlgth</span> <span class="o">=</span> <span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freq</span>
            <span class="n">wvlgth_nm</span> <span class="o">=</span> <span class="n">wvlgth</span> <span class="o">*</span> <span class="mf">1e9</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
            <span class="n">wvlgths</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">wvlgth</span>
            <span class="n">sun_pow</span> <span class="o">=</span> <span class="n">p_wv</span><span class="p">(</span><span class="n">wvlgth_nm</span><span class="p">)</span>
            <span class="n">spectra</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">abs_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">absorb</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">ref_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">ref</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
            <span class="n">trans_vals</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">sun_pow</span> <span class="o">*</span> <span class="n">trans</span> <span class="o">*</span> <span class="n">wvlgth_nm</span>
        <span class="c1"># Now integrate all the weighted spectra and divide by the power of</span>
        <span class="c1"># the spectra</span>
        <span class="n">wvlgths</span> <span class="o">=</span> <span class="n">wvlgths</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">abs_vals</span> <span class="o">=</span> <span class="n">abs_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">ref_vals</span> <span class="o">=</span> <span class="n">ref_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">trans_vals</span> <span class="o">=</span> <span class="n">trans_vals</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">spectra</span> <span class="o">=</span> <span class="n">spectra</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">power</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">spectra</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span>
        <span class="n">wght_ref</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">ref_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
        <span class="n">wght_abs</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">abs_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span> <span class="o">*</span> <span class="mf">1e9</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
        <span class="n">wght_trans</span> <span class="o">=</span> <span class="n">intg</span><span class="o">.</span><span class="n">trapz</span><span class="p">(</span><span class="n">trans_vals</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="n">wvlgths</span><span class="p">)</span> <span class="o">/</span> <span class="n">power</span>
        <span class="n">out</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;weighted_transmission_data.dat&#39;</span><span class="p">)</span>
        <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="s1">&#39;w&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">outf</span><span class="p">:</span>
            <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;# Reflection, Transmission, Absorbtion</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
            <span class="n">outf</span><span class="o">.</span><span class="n">write</span><span class="p">(</span><span class="s1">&#39;</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">,</span><span class="si">%f</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">wght_ref</span><span class="p">,</span> <span class="n">wght_trans</span><span class="p">,</span> <span class="n">wght_abs</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">wght_ref</span><span class="p">,</span> <span class="n">wght_trans</span><span class="p">,</span> <span class="n">wght_abs</span></div>

<div class="viewcode-block" id="SimulationGroup.convergence"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.convergence">[docs]</a>    <span class="k">def</span> <span class="nf">convergence</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">err_type</span><span class="o">=</span><span class="s1">&#39;global&#39;</span><span class="p">,</span> <span class="n">scale</span><span class="o">=</span><span class="s1">&#39;linear&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plots the convergence of a field across all available simulations&quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting convergence&#39;</span><span class="p">)</span>
        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;base_dir&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;local&#39;</span><span class="p">:</span>
            <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;localerror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;global&#39;</span><span class="p">:</span>
            <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;globalerror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">err_type</span> <span class="o">==</span> <span class="s1">&#39;adjacent&#39;</span><span class="p">:</span>
            <span class="n">fglob</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;adjacenterror_</span><span class="si">%s</span><span class="s1">*.dat&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="s1">&#39;Attempting to plot an unsupported error type&#39;</span><span class="p">)</span>
            <span class="k">raise</span> <span class="ne">ValueError</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">fglob</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">paths</span><span class="p">:</span>
            <span class="n">labels</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="n">errors</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">with</span> <span class="nb">open</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s1">&#39;r&#39;</span><span class="p">)</span> <span class="k">as</span> <span class="n">datf</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">line</span> <span class="ow">in</span> <span class="n">datf</span><span class="o">.</span><span class="n">readlines</span><span class="p">():</span>
                    <span class="n">lab</span><span class="p">,</span> <span class="n">err</span> <span class="o">=</span> <span class="n">line</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="s1">&#39;,&#39;</span><span class="p">)</span>
                    <span class="n">labels</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">lab</span><span class="p">)</span>
                    <span class="n">errors</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">err</span><span class="p">)</span>
            <span class="n">fig</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">(</span><span class="n">figsize</span><span class="o">=</span><span class="p">(</span><span class="mi">9</span><span class="p">,</span> <span class="mi">7</span><span class="p">))</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">ylabel</span><span class="p">(</span><span class="s1">&#39;M.S.E of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Number of Fourier Terms&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">labels</span><span class="p">,</span> <span class="n">errors</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">yscale</span><span class="p">(</span><span class="n">scale</span><span class="p">)</span>
            <span class="c1"># plt.xticks(x,labels,rotation=&#39;vertical&#39;)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">tight_layout</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">title</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">base</span><span class="p">))</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                <span class="k">if</span> <span class="s1">&#39;_excluded&#39;</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                    <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;_excluded&#39;</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">excluded</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                <span class="n">name</span> <span class="o">=</span> <span class="s1">&#39;</span><span class="si">%s</span><span class="s1">_</span><span class="si">%s</span><span class="s1">convergence_</span><span class="si">%s%s</span><span class="s1">.pdf&#39;</span> <span class="o">%</span> <span class="p">(</span>
                    <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">base</span><span class="p">),</span> <span class="n">err_type</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">excluded</span><span class="p">)</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">fig</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">gconf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]:</span>
                <span class="n">plt</span><span class="o">.</span><span class="n">show</span><span class="p">()</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">(</span><span class="n">fig</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimulationGroup.plot_scalar_reduce"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.plot_scalar_reduce">[docs]</a>    <span class="k">def</span> <span class="nf">plot_scalar_reduce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot the result of a particular scalar reduction for each group&quot;&quot;&quot;</span>

        <span class="n">sim</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">base</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting scalar reduction of </span><span class="si">%s</span><span class="s1"> for quantity </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">quantity</span><span class="p">))</span>
        <span class="n">cm</span> <span class="o">=</span> <span class="n">plt</span><span class="o">.</span><span class="n">get_cmap</span><span class="p">(</span><span class="s1">&#39;jet&#39;</span><span class="p">)</span>
        <span class="n">max_depth</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;max_depth&#39;</span><span class="p">]</span>
        <span class="n">period</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;array_period&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dx</span><span class="p">)</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">period</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dy</span><span class="p">)</span>
        <span class="n">z</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">max_depth</span> <span class="o">+</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">,</span> <span class="n">sim</span><span class="o">.</span><span class="n">dz</span><span class="p">)</span>
        <span class="n">ftype</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_as&#39;</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
            <span class="n">globstr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;scalar_reduce*_</span><span class="si">%s</span><span class="s1">.npy&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">globstr</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;FIX LOAD IN GLOBAL SCALAR REDUCE&#39;</span><span class="p">)</span>
            <span class="n">globstr</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;scalar_reduce*_</span><span class="si">%s</span><span class="s1">.npy&#39;</span> <span class="o">%</span> <span class="n">quantity</span><span class="p">)</span>
            <span class="n">files</span> <span class="o">=</span> <span class="n">glob</span><span class="o">.</span><span class="n">glob</span><span class="p">(</span><span class="n">globstr</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect file type in config&#39;</span><span class="p">)</span>
        <span class="n">title</span> <span class="o">=</span> <span class="s1">&#39;Reduction of </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
        <span class="k">for</span> <span class="n">datfile</span> <span class="ow">in</span> <span class="n">files</span><span class="p">:</span>
            <span class="n">p</span> <span class="o">=</span> <span class="kc">False</span>
            <span class="k">if</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;npz&#39;</span><span class="p">:</span>
                <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datfile</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">ftype</span> <span class="o">==</span> <span class="s1">&#39;hdf5&#39;</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="s1">&#39;FIX LOAD IN GLOBAL SCALAR REDUCE&#39;</span><span class="p">)</span>
                <span class="n">scalar</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">datfile</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s1">&#39;Incorrect file type in config&#39;</span><span class="p">)</span>
            <span class="n">cs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_plane</span><span class="p">(</span><span class="n">scalar</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zy&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_yz.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                <span class="n">show</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                               <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xz&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;zx&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;z [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_xz.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                <span class="n">show</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;show_plots&#39;</span><span class="p">]</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">z</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                               <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span>
            <span class="k">elif</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;xy&#39;</span> <span class="ow">or</span> <span class="n">plane</span> <span class="o">==</span> <span class="s1">&#39;yx&#39;</span><span class="p">:</span>
                <span class="n">labels</span> <span class="o">=</span> <span class="p">(</span><span class="s1">&#39;y [um]&#39;</span><span class="p">,</span> <span class="s1">&#39;x [um]&#39;</span><span class="p">,</span> <span class="n">quantity</span><span class="p">,</span> <span class="n">title</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;save_plots&#39;</span><span class="p">]:</span>
                    <span class="n">fname</span> <span class="o">=</span> <span class="s1">&#39;scalar_reduce_</span><span class="si">%s</span><span class="s1">_plane_2d_xy.pdf&#39;</span> <span class="o">%</span> <span class="n">quantity</span>
                    <span class="n">p</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="n">fname</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">heatmap2d</span><span class="p">(</span><span class="n">sim</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">cs</span><span class="p">,</span> <span class="n">labels</span><span class="p">,</span> <span class="n">plane</span><span class="p">,</span> <span class="n">pval</span><span class="p">,</span>
                               <span class="n">save_path</span><span class="o">=</span><span class="n">p</span><span class="p">,</span> <span class="n">show</span><span class="o">=</span><span class="n">show</span><span class="p">,</span> <span class="n">draw</span><span class="o">=</span><span class="n">draw</span><span class="p">,</span> <span class="n">fixed</span><span class="o">=</span><span class="n">fixed</span><span class="p">)</span></div>

<div class="viewcode-block" id="SimulationGroup.transmission_data"><a class="viewcode-back" href="../../utils.html#utils.simulation.SimulationGroup.transmission_data">[docs]</a>    <span class="k">def</span> <span class="nf">transmission_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">absorbance</span><span class="p">,</span> <span class="n">reflectance</span><span class="p">,</span> <span class="n">transmission</span><span class="p">,</span> <span class="n">port</span><span class="o">=</span><span class="s1">&#39;Substrate&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Plot transmissions, absorption, and reflectance assuming leaves are frequency&quot;&quot;&quot;</span>

        <span class="n">base</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;General&#39;</span><span class="p">][</span><span class="s1">&#39;results_dir&#39;</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting transmission data for group at </span><span class="si">%s</span><span class="s1">&#39;</span> <span class="o">%</span> <span class="n">base</span><span class="p">)</span>
        <span class="c1"># Assuming the leaves contain frequency values, sum over all of them</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">refl_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">trans_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="n">absorb_l</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_sims</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">i</span><span class="p">,</span> <span class="n">sim</span> <span class="ow">in</span> <span class="nb">enumerate</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">sims</span><span class="p">):</span>
            <span class="c1"># Unpack data for the port we passed in as an argument</span>
            <span class="n">ref</span><span class="p">,</span> <span class="n">trans</span><span class="p">,</span> <span class="n">absorb</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="p">[</span><span class="s1">&#39;transmission_data&#39;</span><span class="p">][</span><span class="n">port</span><span class="p">]</span>
            <span class="n">freq</span> <span class="o">=</span> <span class="n">sim</span><span class="o">.</span><span class="n">conf</span><span class="p">[</span><span class="s1">&#39;Simulation&#39;</span><span class="p">][</span><span class="s1">&#39;params&#39;</span><span class="p">][</span><span class="s1">&#39;frequency&#39;</span><span class="p">][</span><span class="s1">&#39;value&#39;</span><span class="p">]</span>
            <span class="n">freqs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">freq</span>
            <span class="n">trans_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">trans</span>
            <span class="n">refl_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">ref</span>
            <span class="n">absorb_l</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">absorb</span>
        <span class="n">freqs</span> <span class="o">=</span> <span class="p">(</span><span class="n">c</span><span class="o">.</span><span class="n">c</span> <span class="o">/</span> <span class="n">freqs</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">])</span> <span class="o">*</span> <span class="mf">1e9</span>
        <span class="n">refl_l</span> <span class="o">=</span> <span class="n">refl_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">absorb_l</span> <span class="o">=</span> <span class="n">absorb_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">trans_l</span> <span class="o">=</span> <span class="n">trans_l</span><span class="p">[::</span><span class="o">-</span><span class="mi">1</span><span class="p">]</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">figure</span><span class="p">()</span>
        <span class="k">if</span> <span class="n">absorbance</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">log</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="s1">&#39;Plotting absorbance&#39;</span><span class="p">)</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">absorb_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Absorption&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">reflectance</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">refl_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Reflection&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">transmission</span><span class="p">:</span>
            <span class="n">plt</span><span class="o">.</span><span class="n">plot</span><span class="p">(</span><span class="n">freqs</span><span class="p">,</span> <span class="n">trans_l</span><span class="p">,</span> <span class="s1">&#39;-o&#39;</span><span class="p">,</span> <span class="n">label</span><span class="o">=</span><span class="s1">&#39;Transmission&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">legend</span><span class="p">(</span><span class="n">loc</span><span class="o">=</span><span class="s1">&#39;best&#39;</span><span class="p">)</span>
        <span class="n">figp</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">base</span><span class="p">,</span> <span class="s1">&#39;transmission_plots_port</span><span class="si">%s</span><span class="s1">.pdf&#39;</span><span class="o">%</span><span class="n">port</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">xlabel</span><span class="p">(</span><span class="s1">&#39;Wavelength (nm)&#39;</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">ylim</span><span class="p">((</span><span class="mi">0</span><span class="p">,</span> <span class="mf">1.0</span><span class="p">))</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">savefig</span><span class="p">(</span><span class="n">figp</span><span class="p">)</span>
        <span class="n">plt</span><span class="o">.</span><span class="n">close</span><span class="p">()</span></div></div>
</pre></div>

          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="../../index.html">Table Of Contents</a></h3>
  <ul>
<li class="toctree-l1"><a class="reference internal" href="../../Introduction.html">Introduction</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Tutorial.html">Tutorial</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Code.html">Code</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../Code.html#optics">optics</a></li>
</ul>
<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <form class="search" action="../../search.html" method="get">
      <div><input type="text" name="q" /></div>
      <div><input type="submit" value="Go" /></div>
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
      &copy;2017, Kyle Robertson.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 1.6.2</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.10</a>
      
    </div>

    

    
  </body>
</html>