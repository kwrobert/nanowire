import os
import conff
from conff.utils import Munch2, munchify
import posixpath
import itertools
import pprint
from ..utils.utils import get_combos, do_profile, make_hash
from dicthash import generate_hash_from_dict
from line_profiler import LineProfiler
from yaml import load as yload, dump as ydump
try:
    from yaml import CLoader as Loader, CDumper as Dumper
except ImportError:
    from yaml import Loader, Dumper
import json

class Config(Munch2):
    def __init__(self, *args, skip_keys=None, **kwargs):
        super().__init__(*args, **kwargs)
        self.skip_keys = skip_keys if skip_keys is not None else []
        # self.skip_keys = skip_keys + ['ID'] if skip_keys is not None else ['ID']
        self.ID = self.gen_id()

    def __setitem__(self, k, v):
        super().__setitem__(k, v)
        self.gen_id()

    def __delitem__(self, k, v):
        super().__setitem__(k, v)
        self.gen_id()

    def gen_id(self):
        return generate_hash_from_dict(self._d, blacklist=self.skip_keys)

    def _update_id(self):
        self.ID = self.gen_id()

    @staticmethod
    def fromYAML(*args, **kwargs):
        return munchify(yload(*args, **kwargs), factory=Config)

    @staticmethod
    def fromJSON(stream, **kwargs):
        """
        Load config from a JSON stream (either string or file-like object)
        """
        return munchify(json.loads(stream), factory=Config)

    @classmethod
    def fromFile(cls, path, syntax='yaml', **kwargs):
        """
        Load config from a file given a path. File must be in YAML or JSON
        syntax
        """
        syntax = syntax.lower()
        if syntax not in ('yaml', 'json'):
            raise ValueError('Can only load from yaml or JSON files')
        path = os.path.expandvars(path)
        if not os.path.isfile(path):
            raise ValueError("Path {} is not a regular file".format(path))
        d = {'yaml': cls.fromYAML, 'json': cls.fromJSON}
        with open(path, 'r') as stream:
            inst = d[syntax](stream, **kwargs)
        return inst

    def write(self, path):
        """
        Dumps this config object to its YAML representation given a path to a
        file
        """
        path = os.path.expandvars(path)
        with open(path, 'w') as out:
            ydump(self, out, default_flow_style=False)
        return

    def dump(self):
        """
        Returns YAML representation of this particular config
        """
        return ydump(self, default_flow_style=False)


def find_lists(o, keypath=[], list_locs=None, lists=None):
    """
    Find all lists in a dictionary recursively
    """

    list_locs = list_locs if list_locs is not None else []
    lists = lists if lists is not None else []
    if isinstance(o, dict):
        for key in o.keys():
            loc = keypath + [key]
            val = o[key]
            if isinstance(val, list):
                list_locs.append(loc)
                lists.append(val)
            elif isinstance(val, dict):
                find_lists(val, keypath=loc, list_locs=list_locs, lists=lists)
            else:
                continue
    return list_locs, lists


def fn_pint_quantity(*args):
    """
    Parse a pint Quantity in a config file.

    If len(*args) = 1, we assume its a string representing a pint Quantity.
    If len(*args) = 2, we assume its a sequence whose first item is the
    floating point value of the quantity, and whose second item is a string
    representing the units
    """
    raise NotImplementedError('Still need to add pint Quantity functionality')


class Preprocessor:
    """
    This class consumes a configuration template and an optional params file
    and generates all the simulation configuration files, placing them in
    subdirectories named by the Simulation ID
    """

    def __init__(self, template, params=None):
        if not os.path.isfile(template):
            raise ValueError('Template must be a path to a regular file')
        if type(params) == str:
            if not os.path.isfile(params):
                raise ValueError('params must be a path to a regular file or '
                                 'a dict')
            parser = conff.Parser(fns={'Q': fn_pint_quantity})
            self.in_pars = parser.load(params)
        elif isinstance(params, dict):
            parser = conff.Parser(fns={'Q': fn_pint_quantity})
            self.in_pars = parser.parse(params)
        else:
            self.in_pars = {}
        self.template = template
        self.variable = []
        self.optimized = []
        self.confs = []


    def generate_configs(self):
        """
        Generate all the unique Config objects containing a single set of
        parameters. Note that the Config objects generated by this function
        have not necessarily been rendered yet
        """

        locs, lists = find_lists(self.in_pars)
        paths = [posixpath.join(*l) for l in locs]
        combos = itertools.product(*lists)
        # print(list(combos))
        parser = conff.Parser(fns={'Q': fn_pint_quantity})
        names = Munch2.fromDict({'P': self.in_pars})
        for combo in combos:
            for i, val in enumerate(combo):
                path = posixpath.join('P', paths[i])
                names[path] = val
            parser.update_names(names)
            conf = Config(parser.load(self.template),
                          skip_keys=['Postprocessing', 'General'])
            self.confs.append(conf)

    def write_configs(self, out=None):
        """
        Write all configs to disk in directory `out`. If `out` is not provided,
        configs are written in the same directory as the provided template
        """

        if out is None:
            out = os.path.dirname(self.template)
        if not os.path.isdir(out):
            raise ValueError('{} is not a directory'.format(out))

        for i, conf in enumerate(self.confs):
            outdir = os.path.join(out, conf.ID[0:10])
            outfile = os.path.join(outdir, 'sim_conf.yml')
            if not os.path.isdir(outdir):
                os.makedirs(outdir)
            conf.write(outfile)
