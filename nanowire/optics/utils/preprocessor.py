import os
from mako.template import Template
from .utils import get_combos, do_profile
from .config import Config
from line_profiler import LineProfiler
import ruamel.yaml as yaml


class Preprocessor:
    """
    This class consumes a Mako template specifying the entire configuration for
    a job campaign with all the parameter sweeps and whatnot. It then generates
    all the unique individual configurations represented therein, computes a
    unique and reproducible ID for each configuration, and stores them as text
    files in a subdirectory named by ID
    """

    def __init__(self, path):
        # params, body = self.parse_template(path)
        self.gconf = Config(path=path)
        print("preprocessor __init__")
        self.variable = []
        self.optimized = []
        self.confs = []
        # self.gconf = Config(raw_text=template.render(test={'test':1}))


    def parse_template_split(self, path):
        with open(path, 'r') as f:
            s = [st for st in f.read().split('---') if st]
        if len(s) != 2:
            raise ValueError("Invalid configuration file")
        params = yaml.load(s[0], Loader=yaml.Loader)
        return params, s[1]


    def find_variable_params(self, pkey='paramtype', indict={}, keypath=[]):
        """
        Find the parameters that are being swept through by recursing through
        the self.gconf dictionary and searching for dictionary entries
        containing the key `pkey`
        """

        if not indict:
            keyset = set(self.gconf.keys())
            exclude = set(['Postprocessing'])
            keys = keyset.difference(exclude)
            indict = self.gconf
        else:
            keys = indict.keys()
        for key in keys:
            val = indict[key]
            # All variable parameters must specify their type
            if isinstance(val, dict):
                loc = keypath + [key]
                if pkey in val:
                    if val[pkey] == 'variable':
                        self.variable.append(loc)
                    elif val[pkey] == 'optimized':
                        self.optimized.append(loc)
                    else:
                        raise ValueError("Invalid parameter type at"
                                         " {}".format(loc))
                else:
                    self.find_variable_params(pkey=pkey, indict=val, keypath=loc)
            else:
                continue

    def generate_configs(self):
        """
        Generate all the unique Config objects containing a single set of
        parameters. Note that the Config objects generated by this function
        have not necessarily been rendered yet
        """
        
        keys, combos = get_combos(self.gconf, self.variable)
        for combo in combos:
            conf = Config(data=self.gconf.copy())
            for (key, val) in zip(keys, combo):
                conf[key.split('.')] = val
            self.confs.append(conf)

    def _make_config_template(self):
        """
        Make a template config that has all the parameter sweeps replaced with
        the get dictionary
        """
        template_conf = Config(data=self.gconf.copy())
        for keytup in self.variable:
            get_str = '${get'
            for s in keytup:
                get_str += '["{}"]'.format(s)
            get_str += '}'
            template_conf[keytup] = get_str
        return template_conf


    @do_profile(follow=[])
    def render_configs(self):
        """
        Render all configs using Mako
        """
        # temp_conf = self._make_config_template()
        # template = Template(temp_conf.dump())
        # keys, combos = get_combos(self.gconf, self.variable)
        # for i, combo in enumerate(combos):
        #     conf = Config(data=self.gconf.copy())
        #     for key, val in zip(keys, combo):
        #         conf[key.split('.')] = val
        #     rendered_text = template.render(get=conf)
        #     self.confs.append()
        temp_conf = self._make_config_template()
        template = Template(temp_conf.dump())
        import yaml
        for i, conf in enumerate(self.confs):
            # template = Template(conf.dump())
            rendered_text = template.render(get=conf)
            # self.confs[i] = Config(raw_text=rendered_text)
            self.confs[i] = dict(yaml.load(rendered_text, Loader=yaml.CLoader))
        print(len(self.confs))

    def write_configs(self):
        for i, conf in enumerate(self.confs):
            os.makedirs('config_{}'.format(i))
            conf.write(os.path.join('config_{}'.format(i), 'conf.yml'))
        print(len(self.confs))


    def yamlfile_load(self, path):
        """
        Load a YAML file given a path
        """
        if not os.path.isfile(path):
            raise ValueError("Path {} is not a regular YAML file".format(path))
        path = os.path.expandvars(path)
        with open(path, 'r') as cfile:
            text = cfile.read()
        conf = yaml.load(text, Loader=yaml.Loader)
        return conf

    def yamlfile_dump(self, path):
        """
        Dumps this config object to its YAML representation given a path to a file
        """
        path = os.path.expandvars(path)
        with open(path, 'w') as out:
            out.write(yaml.dump(self.data, default_flow_style=False))
        return

    def dump(self):
        """Returns YAML representation of this particular config"""
        return yaml.dump(self.data, default_flow_style=False)

def getItem(context, path):
    print("context = {}".format(context))
    print("context.keys = {}".format(context.keys()))
    print("context.kwargs = {}".format(context.kwargs))
    print("context['local'] = {}".format(context['local']))
    print("context['capture'] = {}".format(context['capture']))
    print("context['caller'] = {}".format(context['caller']))
    print("path = {}".format(path))
    tup = path.split('.')
    try:
        result = context[tup[0]]
        for el in tup[1:]:
            result = result[tup]
    except:
        # result = '${{pp.getItem({})}}'.format(path)
        result = 'blah'
    print(result)
    return result

