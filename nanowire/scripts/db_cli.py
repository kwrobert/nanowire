import os
import unqlite
import click
from nanowire.utils.config import Config
from nanowire.utils.utils import (
    update_retry,
    store_retry
)

exist_read_path = click.Path(exists=True, resolve_path=True, readable=True,
                             file_okay=True, dir_okay=False)
exist_read_dir = click.Path(exists=True, resolve_path=True, readable=True,
                            writable=True, dir_okay=True, file_okay=False)


@click.group()
def opticsdb():
    """
    Tools for managing the database and data generated by the optics library

    Type opticsdb [SUBCOMMAND] --help for help with the various subcommands
    """


@opticsdb.command()
@click.argument('source')
@click.argument('dest')
@click.option('--overwrite', is_flag=True, default=False,
              help="Overwrite any matching IDs in DEST with those from SOURCE "
                   "without prompting")
def merge(source, dest, overwrite):
    """
    Merge the contents of the SOURCE database into DEST. If a sim ID is present
    in both SOURCE and DEST, you will be asked which one you want to keep
    """
    if overwrite:
        prompt = 'Are you sure you want to overwrite all matching IDs in ' \
                 'DEST_DB with those from SOURCE_FILES?'
        click.confirm(prompt, abort=True)

    source_db = unqlite.UnQLite(source)
    source_col = source_db.collection('simulations')
    source_col.create()
    dest_db = unqlite.UnQLite(dest)
    dest_col = dest_db.collection('simulations')
    dest_col.create()

    source_len = len(source_col.all())
    source_kv_len = len(source_db)
    dest_len = len(dest_col.all())
    dest_kv_len = len(dest_db)
    for key, val in source_db.items():
        if 'simulation' in key or '_docid' in key:
            continue
        doc_id = source_db['{}_docid'.format(key)]
        record = source_col.fetch(doc_id)
        print('Source ID: {}'.format(key))
        print('Source Record ID: {}'.format(record['ID'].decode('utf-8')))
        print('Source Document ID: {}'.format(doc_id))
        if record['ID'].decode('utf-8') != key:
            raise ValueError("ID in document and key-val store do not match!")
        with dest_db.transaction():
            # Check if a record with this sim ID is already in the destination
            # database
            if key in dest_db:
                if overwrite:
                    doc_id = dest_db['{}_docid'.format(key)]
                    success = update_retry(dest_col, doc_id, record)
                    if success is False:
                        msg = "Unable to update document {}".format(doc_id)
                        raise RuntimeError(msg)
                    dest_db[key] = val
                elif click.confirm("Sim ID {} exists in DEST. Overwrite?"):
                    doc_id = dest_db['{}_docid'.format(key)]
                    success = update_retry(dest_col, doc_id, record)
                    if success is False:
                        msg = "Unable to update document {}".format(doc_id)
                        raise RuntimeError(msg)
                    dest_db[key] = val
            else:
                success = store_retry(dest_col, record)
                if success is False:
                    RuntimeError("Unable to store new record!")
                print("Destination Document ID: {}".format(success))
                dest_db[key] = val
                dest_db['{}_docid'.format(key)] = success
    dest_len_after = len(dest_col.all())
    dest_kv_len_after = len(dest_db)
    print("Number of source records: {}".format(source_len))
    print("Number of dest records before: {}".format(dest_len))
    print("Number of dest records after: {}".format(dest_len_after))
    print("Number of source keys: {}".format(source_kv_len))
    print("Number of dest keys before: {}".format(dest_kv_len))
    print("Number of dest keys after: {}".format(dest_kv_len_after))
    missing = dest_len_after - dest_len - source_len
    if missing != 0:
        print("!! WARNING !! {} records were not written to the destination".format(missing))
    if dest_kv_len_after - dest_kv_len != source_kv_len:
        missing = dest_kv_len_after - dest_kv_len - source_kv_len
        print("!! WARNING !! {} keys were not written to the destination".format(missing))
    dest_db.close()
    source_db.close()

@opticsdb.command()
@click.argument('source_files', type=exist_read_path, nargs=-1)
@click.argument('dest_db')
@click.option('--overwrite', is_flag=True, default=False,
              help="Overwrite any matching IDs in DEST_DB with those from "
                   "SOURCE_FILES without prompting")
@click.option('--skip-existing', is_flag=True, default=False,
              help="Skip adding configs from SOURCE_FILES that already exist "
                   "in DEST_DB")
def load_files(source_files, dest_db, overwrite, skip_existing):
    """
    Load all SOURCE_FILES into DEST_DB
    """
    if overwrite:
        prompt = 'Are you sure you want to overwrite all matching IDs in ' \
                 'DEST_DB with those from SOURCE_FILES?'
        click.confirm(prompt, abort=True)

    dest_db = unqlite.UnQLite(dest_db)
    dest_col = dest_db.collection('simulations')
    dest_col.create()
    num_files = len(source_files)
    click.echo("Processing {} files".format(num_files))
    remaining_files = num_files
    for source_file in source_files:
        click.echo("{} out of {} files remaining".format(remaining_files,
                                                         num_files))
        click.echo("Processing config file {}".format(source_file))
        conf = Config.fromFile(source_file)
        conf_in_dest = conf.ID in dest_db
        if conf_in_dest and skip_existing:
            click.echo("Skipped adding Config {} to DB".format(conf.ID))
            continue
        elif conf_in_dest and overwrite:
            click.echo("Replacing Config {} in DB".format(conf.ID))
            conf.update_in_db(dest_db, dest_col)
        elif conf_in_dest:
            msg = 'Config {} exists in DB. Overwrite?'.format(conf.ID)
            if click.confirm(msg):
                click.echo("Replacing Config {} in DB".format(conf.ID))
                conf.update_in_db(dest_db, dest_col)
        else:
            click.echo("Adding Config {} to DB".format(conf.ID))
            conf.store_in_db(dest_db, dest_col)
        remaining_files -= 1
    dest_db.close()


@opticsdb.command()
@click.argument('db', type=exist_read_path)
@click.option('-o', '--output-dir', type=exist_read_dir, default=None,
              help="The directory to dump all configs into. Defaults to "
                   "the same directory as the provided DB file")
@click.option('-i', '--conf_id', type=click.STRING, multiple=True,
              help="Only dump these IDs. Can be specified multiple times")
def dump_configs(db, output_dir, conf_ids):
    """
    Dump all configs stored in DB to files

    DB must be a path to an UnQLite file containing the database of simulation
    configs. All configs in the database are dumped to YAML files on disk, with
    the files stored in subdirectories named using the first 10 characters of
    the config ID
    """

    from nanowire.utils.config import dump_configs

    if output_dir is None:
        output_dir = os.path.dirname(db)
    def get_fname(row):
        ID = row['ID'].decode()
        outdir = os.path.join(ID[0:10], 'sim_conf.yml')
        return outdir
    click.secho('Dumping configs ...')
    paths, db = dump_configs(db, outdir=output_dir, IDs=conf_ids,
                             fname=get_fname)
    db.close()
    return None
