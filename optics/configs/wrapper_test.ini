[General]
# Base directory under which to run your simulation(s)
basedir=/home/kyle_robertson/schoolwork/gradschool/nanowire/tests/sweep_time
# Same as above but remains untouched during buildout of directory tree
treebase=/home/kyle_robertson/schoolwork/gradschool/nanowire/tests/sweep_time
# Base length unit defined relative to a meter (so nm would be 10E-9)
base_unit=1E-6
# Path to sun input power file
input_power=/home/kyle_robertson/schoolwork/gradschool/nanowire/code/Input_sun_power.txt
# Output file base name for fields 
base_name=field_data
# Number of output sample in the x, y, and z directions
x_samples=50
y_samples=50
z_samples=100
# Would you like to post process automatically after your run? (Leave empty for no,
# or populate with anything if yes)
postprocess=False
# Run postprocessing in parallel?
post_parallel=False
# Run sims in parallel?
parallel=True
# Adaptive convergence. This will run multiple sims (up to max_iter of them) for each set 
# of params, increasing the number of basis terms until convergenced within the specified difference
adaptive_convergence=False
max_iter=10
max_diff=.1
# The number of cores you would like to keep free. In other words, the number of cores
# you would NOT like to use for running sims. 
reserved_cores = 2
# Would you like to save the plots for each sim?
save_plots=True
# Would you like to show the plots during postprocessing in real time?
show_plots=False
# The location of the script file to be run by the wrapper
sim_script=/home/kyle_robertson/schoolwork/gradschool/nanowire/code/optics/s4_sim.lua
# File type to save as. Choose from (text, npz)
save_as=npz
# Save timing data?
save_time=True

[Simulation]
# These options configure the various FMM formulations used within the simulation. See
# the S4 docs and paper for details 

## These are the defaults
#Verbosity = 0
#LatticeTruncation = Circular
#DiscretizedEpsilon = False
#DiscretizationResolution = 8
#PolarizationDecomposition = False
#PolarizationBasis = Default
#LanczosSmoothing = False
#SubpixelSmoothing = False
#ConserveMemory = False

Verbosity = 1
LatticeTruncation = Circular
DiscretizedEpsilon = False
DiscretizationResolution = 8
PolarizationDecomposition = True
PolarizationBasis = Default
LanczosSmoothing = False
SubpixelSmoothing = False
ConserveMemory = False

[Materials]
# Each entry should contain the desired name for the material, and the path to its nk file 
ITO = /home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/008_ITO_nk_Hz.txt
AlInP = /home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/009_AlInP_nk_Hz.txt
GaAs = /home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/006_GaAs_nk_Walker_modified_Hz.txt
SiO2 = /home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/004_SiO2_nk_Hz.txt
Cyclotene = /home/kyle_robertson/schoolwork/gradschool/nanowire/code/NK/007_Cyclotrene_nk_Hz.txt

[Fixed Parameters]
# The frequency of this simulation in Hz
#frequency=3.29624847947019e14
# Number of basis vectors in simulation
#numbasis=20:400:20

# Geometric params expressed as multiples of your base unit
array_period=.25
nw_height=1.3
alinp_height=1.27
sio2_height=.03
substrate_t=1.
shell_t=.02
ito_t=.3
air_t=.5
emitter_t=.01
intrinsic_t=.05
nw_radius=.075
numbasis=40

[Variable Parameters]
# Specify the parameters you would like to sweep through there.
# Format: start;stop;step_size
# NOTE: This is inclusive of the endpoint
# ALSO NOTE: If you are specifying a sweep through a parameter that must be
# an integer, make sure the difference between your start and end values is 
# evenly divisible by your step size to avoid ambiguity/unexpected results

# Number of terms in x-y Fourier expansion. Increasing this increases
# sim time as N^3 and memory consumption as N^2
#nw_radius = .06:.08:.01
#numbasis=
frequency=9.126174365671036E14,9.385282182835518E14,4.073571930963636E14,8.47840482275983E14,9.64439E14,5.1100031996215644E14,8.737512639924312E14,3.944018022381395E14,7.571527462684144E14,6.535096194026215E14,8.219297005595349E14,6.275988376861732E14,6.794204011190698E14,3.425802388052431E14,8.089743097013108E14,3.684910205216913E14,9.514836091417759E14,4.5917875652926E14,8.867066548506554E14,8.34885091417759E14,5.369111016786046E14,4.980449291039323E14,6.664650102608456E14,6.405542285443975E14,7.05331182835518E14,6.923757919772939E14,7.960189188430866E14,6.146434468279492E14,7.18286573693742E14,7.441973554101902E14,3.555356296634672E14,7.312419645519661E14,4.332679748128118E14,7.701081371266385E14,5.628218833950528E14,5.75777274253277E14,3.814464113799154E14,4.462233656710359E14,8.996620457088795E14,4.721341473874841E14,5.239557108203805E14,5.88732665111501E14,5.4986649253682875E14,4.2031258395458775E14,4.8508953824570825E14,7.830635279848625E14,8.607958731342072E14,9.255728274253276E14,3.29624847947019E14,6.016880559697251E14

[Sorting Parameters]
# These are parameters you would like to sweep through and create a directory tree for each parameter.
# All the variable params specified above will then be swept through in each of these subdirectories. 
# The part before the semi colon specifies the sweep just as above. The part after the semi colon is a 
# sorting key used to determine the order of the parameter directory in the directory tree. Lower numbers 
# place the directory closer to the top of the tree. 
# Format: start:end:step;sorting_key
#nw_radius = .06:.08:.01;1

[Evaluated Parameters]
# These are parameters that need to be computed at runtime because they depend on the values of some 
# other parameters that are being swept through. For example, you want to sweep through different
# nanowire core radii while keeping the total core & shell diameter fixed. You could sweep through
# radii, then define the shell thickness down here as shell = diameter - radius
# This syntax may be slightly confusing. Here are the steps:
# 1. This config file is parsed by sim_wrapper WITHOUT interpolation. This preserves the interpolation 
#    syntax below AS IS
# 2. When the individual simulation config file is created, the values below are surrounded in back 
#    ticks to denote that they are expressions that must be evaluated properly.
# 3. When the individual sim config is parsed by the simulation script, interpolation is activated
#    so the parameters %(in here) are resolved to actual numbers. Only basic interpolation is 
#    required because all parameters are within the same, single [Parameters] section in the 
#    individual sim config file. 
# 4. The simulation script scans its config file for parameters surrounded by back ticks. If it finds
#    any, it strips the back ticks, evaluates the expression, and sets the parameter to the result
#shell_t = .11 - %(nw_radius)s 

[Cruncher]
# What quantities would you like to calculate for each simulation?
# Format with the quantity as the option name and 
# the arguments to that quantity's calculating function
# as a comma seperated list of values. Can supploy multiple sets of 
# arguments by seperating multiple comma-seperated lists with a semi-colon
#normE=
normEsquared=
#normH=
#normHsquared=
genRate=

[Global_Cruncher]
# Compute global quantities
# Parameters:
# 1) The field to compute the error of
# 2) Exclude or do not exclude the air and substrate regions when 
#    computing the error
# Example: global_error=E,True
#local_error=E
#global_error=E,True

[Plotter]
# If you do, what kind of plots would you like to generate?
# Must choose from a list of supported options!!!
#full_3d=normE
#planes_3d=normE,25,25
# plane_2d=normE,z,46,True,False 
# 1) Value to plot
# 2) x,y, or z plane?
# 3) Which plane value?
# 4) Draw nanowire components?
# 5) Fix colorbar limits? 
#plane_2d=normE,z,100,True;normE,x,50,True
plane_2d=genRate,x,25,True
#fixed_line=normE,z,25,25

[Global_Plotter]
#convergence=E,global,log;E,local,log
