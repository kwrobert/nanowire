General:
    
    # Base directory under which to run your simulation(s)
    base_dir: '$HOME/schoolwork/gradschool/nanowire/code/optics/test'
    # Same as above but remains untouched during buildout of directory tree
    treebase: '$HOME/schoolwork/gradschool/nanowire/code/optics/test'
    # The name of the database file that will store simulation state and output
    # data
    db_name: 'test_run.db'
    # Output file base name for fields 
    base_name: 'field_data'
    # Would you like to post process automatically after your run? 
    postprocess: False
    # Run postprocessing in parallel?
    post_parallel: False
    # How would you like to execute the simulations?
    # Choose from ['serial','parallel','gc3']. Serial means execute all sims
    # serially on local machine, parallel means execute in parallel on local
    # machine using num_cores cores, gc3 means submit using gc3pie
    execution: 'gc3'
    # Adaptive convergence. This will run multiple sims (up to max_iter of them) for each set 
    # of params, increasing the number of basis terms by basis_step until converged within max_diff
    adaptive_convergence: False
    max_iter: 5 
    max_diff: .02
    basis_step: 20
    # Maximum number of iterations and tolerance for any optimizations
    opt_max_iter: 50
    opt_tol: 1e-4
    opt_keep_intermediates: False
    # The number of cores you would like to use for running simulations in
    # parallel. Only used if execution = 'parallel'
    num_cores: 4
    # Would you like to save the plots for each sim?
    save_plots: True
    # Would you like to show the plots during postprocessing in real time?
    show_plots: False
    # File type to save as. Choose from (text, npz)
    save_as: 'npz'
    # Save timing data?
    save_time: True
    # Output patterning in each layer
    output_pattern: True
    ignore_h: True

Solver:
# These options configure the various FMM formulations used within the simulation. See
# the S4 docs and paper for details 

## These are the defaults
#Verbosity = 0
#LatticeTruncation = Circular
#DiscretizedEpsilon = False
#DiscretizationResolution = 8
#PolarizationDecomposition = False
#PolarizationBasis = Default
#LanczosSmoothing = False
#SubpixelSmoothing = False
#ConserveMemory = False
    Verbosity: 0
    LatticeTruncation: 'Circular'
    DiscretizedEpsilon: False
    DiscretizationResolution: 8
    PolarizationDecomposition: True
    PolarizationBasis: 'Default'
    LanczosSmoothing: False
    SubpixelSmoothing: False
    ConserveMemory: False

Simulation:
    # This section handles global simulation parameters that are not specific to any given
    # layer. For example, the lattice vectors or the angle of incident light
    # The polarization of incident light (all normally incident)
    # Right Hand Circularly Polarized : rhcp
    # Left Hand Circularly Polarized : lhcp
    # Linearly Polarized Along X : lpx
    # Linearly Polarized Along Y : lpy
    # NOTE: Now that we can specify incident angles we might need to modify this
    polarization: 'rhcp'
    average_bins: True
    # Number of output sample in the x, y, and z directions
    # every 2 nm
    x_samples: 10
    y_samples: 10
    # every 10 nm
    # z_samples: 350
    # z_samples: '`round((%(Layers.Air.params.thickness.value)s+%(Layers.ITO.params.thickness.value)s+%(Layers.NW_AlShell.params.thickness.value)s+3)*50)`'
    z_samples: 10
    r_samples : 150
    theta_samples : 360
    # Maximum depth into the device to collect field data
    max_depth: '`%(Layers.Air.params.thickness.value)s+%(Layers.ITO.params.thickness.value)s+%(Layers.NW_AlShell.params.thickness.value)s+3`'
    # Base length unit defined relative to a meter (so nm would be 1E-9)
    base_unit: 1.0E-6
    # Path to sun input power file
    input_power: '$HOME/software/nanowire/am15g_freq.txt'
    input_power_wv: '$HOME/software/nanowire/ASTMG173.csv'
    # Global simulation parameters that are "sweepable"
    params:
        # The angle of the incident light
        polar_angle:
            type: 'fixed'
            value: 0
        azimuthal_angle: 
            type: 'fixed'
            value: 0
        # Periodicity of the square array. NOTE: Currently this only supports a square
        # lattice. Support for non-square unit cells may be added in the future
        array_period:
            type: 'fixed'
            value: .315
        frequency:
            type: 'variable'
            start: 333102731111111.1
            end: 856549880000000.0
            step: 5
            itertype: 'numsteps'
        numbasis:
            type: 'fixed'
            value: 10

Materials:
    ITO: '$HOME/software/nanowire/NK/008_ITO_nk_Hz.txt'
    Cyclotene: '$HOME/software/nanowire/NK/007_Cyclotrene_nk_Hz.txt'
    GaAs: '$HOME/software/nanowire/NK/006_GaAs_nk_Walker_modified_Hz.txt'
    AlInP: '$HOME/software/nanowire/NK/009_AlInP_nk_Hz.txt'

Layers:
    Air:
        order: 1
        base_material: 'vacuum'
        params:
            thickness:
                type: 'fixed'
                value: .5
    ITO:
        order: 2
        base_material: 'ITO' 
        params:
            thickness:
                type: 'fixed'
                value: .3
    NW_AlShell: 
        order: 3 
        base_material: 'Cyclotene'
        params:
            thickness: 
                type: 'fixed'
                value: 3.0
                # type: 'variable'
                # itertype: 'stepsize'
                # start: 1.5
                # end: 4
                # step: .5
            core_radius:
                type: 'fixed'
                value: .106
        geometry:
            core:
                order: 2
                type: 'circle'
                radius: '%(Layers.NW_AlShell.params.core_radius.value)s'
                center:
                    x: '`%(Simulation.params.array_period.value)s/2`'
                    y: '`%(Simulation.params.array_period.value)s/2`'
                material: 'GaAs' 
    Substrate:
        order: 4
        base_material: 'GaAs'
        params:
            thickness:
                type: 'fixed'
                value: 100

Postprocessing:
    Cruncher:
        # What quantities would you like to calculate for each simulation?
        # The quantities specific to each simulation that you would like to calculate. Specify
        # compute: False 
        # to disable the calculation, and True to enable it. Arguments can be passed to each
        # option as a list. If you would like to run the function multiple times with multiple
        # sets of arguments, specify a list of lists like so:
        # single run: ['arg1',3,'arg2']
        # multiple runs: [['arg1,3,'arg2'],['arg3',4,'arg4']]
        normE:
            compute: True
            args:
        normEsquared:
            compute: True
            args:
        normH:
            compute: False
            args:
        normHsquared:
            compute: False
            args:
        genRate:
            compute: True
            args:
        angularAvg:
            compute: True
            args: ['genRate']
        transmissionData:
            compute: True
            args:
        integrated_absorbtion:
            compute: False
            args:
    
    Global_Cruncher:
    # Compute global quantities
    # Parameters:
    # 1) The field to compute the error of
    # 2) Exclude or do not exclude the air and substrate regions when 
    #    computing the error
        local_error:
            compute: False
            args: ['E',False]
        global_error:
            compute: False
            args: ['E',False]
        adjacent_error:
            compute: False
            args: ['E',False]
        global_avg:
            compute: False
            args: ['genRate','angularAvg']
        Jsc:
            compute: True
            args:
        weighted_transmissionData:
            compute: False
            args:
    
    Plotter:
    # If you do, what kind of plots would you like to generate?
    # Must choose from a list of supported options!!!
        full_3d:
            compute: False
            args: ['normE']
        planes_3d: 
            compute: False
            args: ['normE',5,5]
        plane_2d:
        # 1) Value to plot
        # 2) x,y, or z plane?
        # 3) Which plane value?
        # 4) Draw nanowire components? (default: False)
        # 5) Fix colorbar limits? (default: False)
            compute: True
            args: [['normE',x,5,True],['normE','z',10,True]]
        fixed_line:
            compute: False
            args: ['normE','z',5,5]
    
    Global_Plotter:
        convergence:
            compute: False
            args: [['E','global','log'],['E','local','log'],['E','adjacent','log']]
        global_avg: 
            compute: False
            args: ['genRate','angularAvg']
        transmission_data:
            # Absorbtion, Reflectance, Transmission (pass false to disable one) 
            compute: True
            args: [True,True,True]
